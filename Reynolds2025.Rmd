---
title: "Social needs for transport and gaps in transit service: Enniscorthy and other parts of County Wexford, Ireland"
runningheader: "Enniscorthy, Ireland:transit needs-gaps" # only for pdf output
author: "Dr James Reynolds"
date: "`r Sys.Date()`"
bibliography: References.bib
csl: https://www.zotero.org/styles/chicago-fullnote-bibliography-16th-edition
suppress-bibliography: yes
output:
#  tufte::tufte_html: default
  tufte::tufte_handout:
#    citation_package: natbib
#    latex_engine: xelatex
#  tufte::tufte_book:
#    citation_package: natbib
#    latex_engine: xelatex

---

```{r setup, include=FALSE}
library(tidyverse)
library(tidytransit)
library(sp)
library(strayr)
library(ptinpoly)
library(magrittr)
library(ggplot2)
library(sf)
library(ASGS.foyer)
library(raster)
library(ggmap)
library(units)
library(janitor)
library(mapview)
library(ggstatsplot)
library(gtsummary)
library(moments)
library(scales)
library(gtfstools)
library(lubridate)
library(kableExtra)
library(knitr)
library(readxl)
library(readr)
library(dplyr)
library(devtools)
library(gtfssupplyindex)
library(readabs)
library(gglorenz)
library(DescTools)
library(RColorBrewer)
library(lsr)
library(ggpubr)
library(viridis)
library(geosphere)
library(png)
library(absmapsdata)
library(tidytransit)
library(patchwork)
library(ggmapinset)
library(tufte)

knitr::opts_chunk$set(warning = FALSE, message = FALSE) 

```

# Introduction
The CONUNDRUM project relates to sustainable transport,
community mobility 
and co-creation,
and is using Enniscorthy 
in County Wexford, Ireland, 
as a test bed. 
However, 
assessments and mapping of 
social needs for transport, 
and public transport supply 
provided in Enniscorthy, 
and how these compare to other places in Ireland, 
do not appear to be publically available.  
Currie et al[-@Currie2003Hobart; -@Currie2004Gap; -@Currie2007Identifying; @currie2010identifying] 
developed a methodology for assessing 
spatial gaps between social needs 
and transit supply 
An R package^[See
https://github.com/James-Reynolds/gtfssupplyindex] 
has recently been developed 
that facilitates 
the calculation of the 
transit supply levels 
from General Transit Feed Specification (GTFS) 
datasets. 

This note presents results 
obtained by applying 
the gtfssupply index R package 
to Ireland's GTFS dataset,  
with an emphasis on Enniscorthy 
in county Wexford.


# Background

## Transit supply
The social needs-gap 
analysis methodology
involves calculating 
a Supply Index (SI) 
based on the 
number of transit service arrivals 
at stops in and around 
each area of interest. 
Adjustments are made 
for the amount of 
each area 
that is within 
a typical walking distance 
of each stop, 
according to the following 
formula: 

$$SI_{area, time} = \sum{\frac{Area_{Bn}}{Area_{area}}SL_{n, time}}$$

where:

-   $SI_{area, time}$ is the Supply Index for the area of interest and a given period of time;

-   $Area_{Bn}$ is the buffer area for each stop (n) within the area of interest^[In @currie2010identifying this was based on a radius of 400 metres for bus and tram stops, and 800 metres for railway stations. The same definition is used here.];

-   $Area_{area}$ is the area of the area of interest; and

-   $SL_{n,time}$ is the number of transit arrivals for each stop within the given time period.

As such, 
the SI combines
coverage (accessibility to transit) 
and service frequency (accibility by transit). The 
SI is a relative index, 
allowing comparison between 
different areas of interest, 
based on transit supplied over a 
specific time period. In the results reported in 
@currie2010identifying 
transit supply was 
assessed based on 
an entire week, 
and compared across 
Census Collection Districts (CCDs)
within Greater Melbourne. 
CCDs were clasify into 
seven groups 
based on SI scores^[ 
being those with: 
zero supply; 
very low, 
low, 
or below average supply; 
and above average, 
high 
or very high supply.  
CCDs with above and below average
SIs were evenly split into each of the 
three sub-groups, respectively.]. 

## Transport needs
Transport needs were similarly 
assessed using a index score, 
based on various metrics
available from the Australian Bureau of Statistics (ABS). 
These included 
the Index of Relative Socio-Economic Advantage/Disadvantage (IRSAD), 
which is reported directly 
by the ABS 
based on 31 weighted indicators 
and data collected during the census. A transport-specific need index, 
based on eight weighted indicators^[Adults without cars (0.19), 
distance to the Melbourne Central Business District (0.15), 
persons aged over 60 years (0.14), 
persons on a disability pension (0.12), 
low income households (0.10), 
adults not in the labour force (0.09), 
students (0.09) and 
persons 5-9 years (0.12).] 
was also included, 
with scores 
categorised based on 
three groups below 
and three groups above 
the average score across all of Melbourne.  

Clearly, 
the approach used to assess
social needs for transport 
might need to be adjusted 
to reflect different data availability 
in different locations 
or from different editions of a census.  

## Needs-gaps

The final step was to compare 
social needs for transport 
with 
the amount of transit 
supplied 
in each area of interest. A key finding was that 
"8.2% of Melbourne residents ha(d) ‘very high’ needs but
‘zero’, ‘low’ or ‘very low’ public transport supply", 
reflective of 
areas of greater need 
often being in places 
on urban fringes 
or otherwise often remote from 
transit infrastructure and services.  
More broadly, it was suggested that 
the developed methodology 
might be "substantially more useful than the presentation of
anecdotal evidence which is the most common means 
of identifying transport needs in local transport studies throughout the
world``[@currie2010identifying].

# Methodology
# Supply Index

This analysis used the all-Ireland GTFS 
dataset, downloaded on April 23, 2025 
and reporting scores for transit services 
provided on that same date (the first Wednesday after Easter). The "Small Area" National Statistical Boundaries from 2022 
were adopted as the areas of interest, 
with the indexing of supply based on 
the average score across the County of Wexford.  


```{r load_ireland_gtfs, eval = FALSE, echo = FALSE}

ireland_250423 <- tidytransit::read_gtfs("data/GTFS_All.zip")

## convert to list of tidygtfs objects
ireland_250423_list_gtfs <- gtfssupplyindex::gtfs_by_route_type("data/GTFS_All.zip")


```

```{r run_for_all_modes_ireland_, eval = FALSE, echo = FALSE}

list_gtfs = ireland_250423_list_gtfs


Small_Area_National_Statistical_Boundaries_2022 <- st_read("data/Small_Area_National_Statistical_Boundaries_2022_Ungeneralised_view_-7354763930310470674.gpkg")
st_geometry(Small_Area_National_Statistical_Boundaries_2022) <- "SHAPE"

wexford <- Small_Area_National_Statistical_Boundaries_2022 %>% 
  filter(COUNTY_ENGLISH == "WEXFORD") %>%
  select(SA_PUB2022)

names(wexford) <- c("sa_pub2022", "geometry")
wexford <- st_set_geometry(wexford, "geometry")


#Load Wexford codes
areas_of_interest <- load_areas_of_interest(wexford,  
  area_id_field = "sa_pub2022")


stops_in_or_near_areas <- gtfssupplyindex:::stops_in_walk_dist(
  list_gtfs = list_gtfs, 
  areas_of_interest = areas_of_interest,
  EPSG_for_transform = 2157,
  verbose = FALSE
)



si_wexford_250423_day <- SI_by_day_hour_and_route_type(
     list_gtfs = list_gtfs, 
stops_in_or_near_areas = stops_in_or_near_areas,
 start_date_ymd = "2025-04-23", 
 end_date_ymd = "2025-04-23",
verbose = TRUE)

write.csv(si_wexford_250423_day, "results/si_wexford_250423_day")


si_wexford_250423_day_aggregated <- si_wexford_250423_day %>% 
           group_by(area_id) %>%    
           summarize(SI = sum(SI))

write.csv(si_wexford_250423_day_aggregated, "results/si_wexford_250423_day_aggregated.csv")


```


## Needs

The Irish Census (2022) reports various indicators for "Small Area", but these do not match those used in the Currie (2007) or other previous needs-gap analyses.  However, there are some that are similar^[Item T15_1_NC is the number of households without a motor car. Items T1_1_AGE60-64T, T1_1_AGE65-69T, ... T1_1_AGE80-84T and T1_1_AGE85T report persons aged 60 years and older; T8_1_UTWSDT reports the total number of people unable to work due to permanent sickness or disability; T8_1_TT reports the total population aged 15 years and over, while T8_1_WT reports the total at work, thereby allowing calculation of the number of adults (15+) not in the labour force; T8_1_ST reports the number of people aged 15 years and over who are students; and T1_1AGE5T, T1_1AGE6T ... T1_1AGE9T report the number of people aged 5 through 9. There does not appear to be any data available about low income households at the "Small Area" geographic area.], but there does not appear to be a IRSAD or similar socio-economic indicator available. 

As such, this analysis adapts the Currie (2007) approach and uses the same weighting for the following indicators: households without cars (0.19); distance to Wexford (0.15); persons aged 60 years and over (0.14), persons unable to work due to permant sickness or disability (0.12), those aged 15 years or older who are not at work; students (0.09) and people aged 5-9 years (0.12).  Each of these indicators were normalised across all of the Small Areas in County Wexford, weighted as indicated to develop an combined value that was then weighted by the total population in each Small Area to produce the combined indicator of social need for transport used in this analysis. 


```{r read_census_data_2021, fig.show="hold", eval= TRUE, echo = FALSE, warning=FALSE, message=FALSE, cache=TRUE, fig.fullwidth = TRUE, fig.cap="SI scores by SA3, census day 2016 and 2021"}

SAPS_2022_Small_Area_UR_171024 <- read_csv("data/SAPS_2022_Small_Area_UR_171024.csv")

SAPS_2022_Small_Area_UR_171024 <- SAPS_2022_Small_Area_UR_171024 %>% 
  clean_names()

social_needs <- SAPS_2022_Small_Area_UR_171024 %>% 
  select(guid, geogid, geogdesc, ur_category, ur_category_desc) 
 
 
social_needs$over_60 <- SAPS_2022_Small_Area_UR_171024 %>% 
  select(t1_1age60_64t, t1_1age65_69t, t1_1age70_74t, t1_1age75_79t, t1_1age80_84t, t1_1agege_85t) %>% 
  sum()


social_needs$age_five_to_nine <- SAPS_2022_Small_Area_UR_171024 %>% select(
  t1_1age5t, t1_1age6t, t1_1age7t, t1_1age8t, t1_1age9t) %>%
  sum()

social_needs$adult_no_car <- NA
social_needs$low_income_families <- NA

social_needs$adult_not_labour_force <- SAPS_2022_Small_Area_UR_171024$t8_1_tt - 
  SAPS_2022_Small_Area_UR_171024$t8_1_wt

social_needs$students <- SAPS_2022_Small_Area_UR_171024 %>% select(
  t8_1_st)

social_needs$IRSAD <- NA

social_needs$population <- SAPS_2022_Small_Area_UR_171024 %>% select(t1_1agett)


##Rescaling to 0-100 and adding the accessibility indicator needs to be done on a areas_of_interest by areas_of_interest bias, as which areas are included will matter. 

```

# Results

## County Wexford 


```{r Wexford_2025, fig.show="hold", out.width="100%", echo = FALSE, warning=FALSE, message=FALSE,  cache=FALSE, results='hide'}

## FUNCTION to define thresholds and return Very High, High etc. 
# as per Currie2010 Table 3 and page 34. 
# the approach appears to be to first identify zones that have zero supply 
# the remainder are then split into those above and below the average SI value
# these two groups are then each split into three groups of roughly equal size. 
set_thresholds <-function(si_by_area_dataframe){ 

## Define Very High, High etc thresholds
cuts_lower_groups <- si_by_area_dataframe %>% 
  st_drop_geometry() %>% 
  filter(SI !=0) %>%
  filter(SI <= SI %>% mean()) %>% 
  select(SI) %>% unlist() %>% 
  as.vector() %>% 
  quantileCut(3)

cuts_upper_groups <- si_by_area_dataframe %>% 
  st_drop_geometry() %>% 
  filter(SI !=0) %>%
  filter(SI > SI %>% mean()) %>%
  select(SI) %>% unlist() %>% 
  as.vector() %>% 
  quantileCut(3)

# Recode lower_group factors
allocation_lower_groups <- cuts_lower_groups %>% fct_recode(
  "Very Low" = levels(cuts_lower_groups)[1], 
  "Low" = levels(cuts_lower_groups)[2], 
  "Below average" = levels(cuts_lower_groups)[3])

# Recode upper_group factors
allocation_upper_groups <- cuts_upper_groups %>% fct_recode(
  "Above average" = levels(cuts_upper_groups)[1], 
  "High" = levels(cuts_upper_groups)[2], 
  "Very High" = levels(cuts_upper_groups)[3])


# Join back to lower_group SIs and areas_of_interest
si_by_area_dataframe_below_average <- si_by_area_dataframe %>% 
  st_drop_geometry() %>% 
  filter(SI !=0) %>%
  filter(SI <= SI %>% mean()) 
si_by_area_dataframe_below_average$transit_supply <- allocation_lower_groups

# Join back to upper_group SIs and areas_of_interest
si_by_area_dataframe_above_average <- si_by_area_dataframe %>% 
  st_drop_geometry() %>% 
  filter(SI !=0) %>%
  filter(SI > SI %>% mean()) 
si_by_area_dataframe_above_average$transit_supply <- allocation_upper_groups

# combine upper and lower groups
  
si_by_area_dataframe_non_zero <- add_row(si_by_area_dataframe_below_average, 
                                         si_by_area_dataframe_above_average)

#join back to dataframe, and put "Zero" in N/A
si_by_area_dataframe <- full_join(
  si_by_area_dataframe %>% 
    st_drop_geometry(), 
  si_by_area_dataframe_non_zero
)

si_by_area_dataframe$transit_supply <- si_by_area_dataframe$transit_supply %>% 
  fct_explicit_na(na_level = "Zero Supply") %>% 
  fct_shift(n = -1)

#return dataframe and information about level cut offs
si_by_area_dataframe_and_cuts_dataframe <- list(
  si_by_area_dataframe,
  c(levels(cuts_lower_groups), levels(cuts_upper_groups))
  )
return(si_by_area_dataframe_and_cuts_dataframe)
}
# END FUNCTION

## FUNCTION to set thresholds and return tibble, plot output and thresholds
si_thresholds_and_plot_function <- function(si_by_area, areas_of_interest){
# Set column names
names(si_by_area) <- c("area_id", "SI")
names(areas_of_interest) <- c("area_id", "geometry")
  
si_by_area$area_id <- si_by_area$area_id %>% 
  as.character()


##Join to areas_of_interest so as to identify (and enumerate as zero) 
# those areas of interest that have no SI score 

si_by_area <- full_join(
  areas_of_interest,
  si_by_area)
si_by_area[is.na(si_by_area)] <- 0

si_by_area_thresholds <- set_thresholds(si_by_area_dataframe = si_by_area)
si_by_area <- si_by_area_thresholds[[1]]


si_by_area <- left_join(
  areas_of_interest, 
  si_by_area)

output_plot <- ggplot()+ 
  geom_sf(data=si_by_area %>% na.omit(),
          aes(fill = transit_supply), colour=NA) +
  theme(axis.text.x=element_blank(), #remove x axis labels
        axis.ticks.x=element_blank(), #remove x axis ticks
        axis.text.y=element_blank(),  #remove y axis labels
        axis.ticks.y=element_blank(), #remove y axis ticks
        legend.position="none",
#        legend.text = element_text(size = 4), 
#        legend.title = element_text(size = 5), 
#        legend.key.size = unit(0.08, 'cm')
        ) + 
  scale_fill_manual(values = c("white", "#F9D8B1", "#F7C387", "#F29C33", "lightgreen", "#53A212", "darkgreen")) 


  outputs <- list("si_by_area" = si_by_area, 
                  "output_plot" = output_plot, 
                  "thresholds" = si_by_area_thresholds[[2]])
  return(outputs)
}

### Load 2025 results
si_by_area <- read.csv("results/si_wexford_250423_day_aggregated.csv") %>% 
  as_tibble()
si_by_area <- si_by_area[,2:3]


#Load Wexford codes


Small_Area_National_Statistical_Boundaries_2022 <- st_read("data/Small_Area_National_Statistical_Boundaries_2022_Ungeneralised_view_-7354763930310470674.gpkg")
st_geometry(Small_Area_National_Statistical_Boundaries_2022) <- "SHAPE"

wexford <- Small_Area_National_Statistical_Boundaries_2022 %>% 
  filter(COUNTY_ENGLISH == "WEXFORD") %>%
  select(SA_GUID_2022, SA_PUB2022, SA_URBAN_AREA_NAME, SA_NUTS2_NAME, SA_NUTS3_NAME)

names(wexford) <- c("SA_GUID_2022", "SA_PUB2022", "SA_URBAN_AREA_NAME", "SA_NUTS2_NAME", "SA_NUTS3_NAME", "geometry" )
wexford <- wexford %>% st_set_geometry("geometry")

#Load Wexford codes
areas_of_interest <- load_areas_of_interest(wexford,  
  area_id_field = "SA_PUB2022")

si_wexford_250423_day_aggregated <- si_thresholds_and_plot_function(si_by_area, areas_of_interest)

## Connect SI results to area definitions
si_wexford_250423_day_aggregated$si_by_area <- left_join(
  si_wexford_250423_day_aggregated$si_by_area,
  wexford %>% st_drop_geometry(), 
  by=join_by("area_id" == "SA_PUB2022"))


## Import population data
## T1_1AGETT is total population field.  
# GUID is identification field
SAPS_2022_Small_Area_UR_171024 <- read_csv("data/SAPS_2022_Small_Area_UR_171024.csv") %>% select(GUID, T1_1AGETT) 

names(SAPS_2022_Small_Area_UR_171024) <- c("GUID", "population")

si_wexford_250423_day_aggregated$si_by_area <- left_join(
  si_wexford_250423_day_aggregated$si_by_area,
  SAPS_2022_Small_Area_UR_171024, 
  by=join_by("SA_GUID_2022" == "GUID"))

# Categorise population into Very High, High groups etc.
wexford_population <- si_wexford_250423_day_aggregated$si_by_area %>% 
  st_drop_geometry() %>% 
  select(area_id, population)
names(wexford_population) <- c("area_id", "SI")
wexford_population <- set_thresholds(wexford_population)
names(wexford_population[[1]]) <- c("area_id", "population", "population_category")

si_wexford_250423_day_aggregated$si_by_area$population_category <- 
  wexford_population[[1]]$population_category

si_wexford_250423_day_aggregated$si_by_area$population_category <- 
  si_wexford_250423_day_aggregated$si_by_area$population_category %>%
  factor(levels=c("Very Low", "Low", "Below average", "Above average", "High", "Very High"))

#Calculate population density
si_wexford_250423_day_aggregated$si_by_area$population_density <- 
  si_wexford_250423_day_aggregated$si_by_area$population %>% st_drop_geometry() /
  si_wexford_250423_day_aggregated$si_by_area %>% st_area()
#Categorise population density  
wexford_population_density <- si_wexford_250423_day_aggregated$si_by_area %>% 
  st_drop_geometry() %>% 
  select(area_id, population_density)
names(wexford_population_density) <- c("area_id", "SI")
wexford_population_density$SI <- wexford_population_density$SI %>%
  as.numeric()
  
wexford_population_density <- set_thresholds(wexford_population_density)
names(wexford_population_density[[1]]) <- c("area_id", "population_density", "density_category")

si_wexford_250423_day_aggregated$si_by_area$density_category <- 
  wexford_population_density[[1]]$density_category

si_wexford_250423_day_aggregated$si_by_area$density_category <- 
  si_wexford_250423_day_aggregated$si_by_area$density_category %>%
  factor(levels=c("Very Low", "Low", "Below average", "Above average", "High", "Very High"))



```



```{r SI_map_wexford_county_population, fig.show="hold", eval = TRUE, echo = FALSE, warning=FALSE, message=FALSE, cache=FALSE, fig.margin = TRUE, fig.cap="Transit Supply across County Wexford, by population"}


#Set boundings box
bbox_list <- wexford %>% 
  st_geometry %>% 
  st_combine() %>%
  st_bbox()


lat = c(bbox_list["ymin"] %>% as.numeric(), bbox_list["ymax"] %>% as.numeric())
lon = c(bbox_list["xmin"] %>% as.numeric(), bbox_list["xmax"] %>% as.numeric() + 0*(bbox_list["xmax"] %>% as.numeric() - bbox_list["xmin"] %>% as.numeric()))

Poly_Coord_df = data.frame(lon, lat)

poly <- Poly_Coord_df %>% 
  st_as_sf(coords = c("lon", "lat"), 
           crs = 2157) %>% 
  st_bbox() %>% 
  st_as_sfc()


pcol_si_wexford_county <- si_wexford_250423_day_aggregated$si_by_area %>%
  st_drop_geometry() %>%
  aggregate(population ~ transit_supply, sum) %>%
  right_join(tibble(transit_supply = si_wexford_250423_day_aggregated$si_by_area$transit_supply %>% levels())) %>%
  replace_na(list(population = 0)) %>%
  mutate(transit_supply=factor(transit_supply, levels = si_wexford_250423_day_aggregated$si_by_area$transit_supply %>% levels())) %>%
  arrange(transit_supply) %>%
  mutate(perc=population/sum(population)) %>% 
  na.omit() %>%
  ggplot() + 
  geom_col(aes(transit_supply, perc, fill = transit_supply), colour="black") +
  scale_y_continuous(limits = c(0,.6)) +
  geom_hline(yintercept = 0)  + 
  geom_text(aes(transit_supply,  0.5, label = glue::glue("{label_comma(accuracy = 1, big.mark = ",")(population)} ({label_percent(accuracy = 1)(perc)})"))) +
   coord_flip() + 
scale_fill_manual(values = c("Zero Supply" = "white", "Very Low" = "#F9D8B1", "Low" = "#F7C387", "Below average" = "#F29C33", "Above average" = "lightgreen", "High" = "#53A212", "Very High" = "darkgreen")) +
  scale_color_manual(values = c(rep("black", 5), rep("white", 2), "black")) +
  guides(fill = "none", color = "none") +
  labs(
    title = "Transit supply by population",
    x = NULL,
    y = NULL
  ) +
  theme_void() +
  theme(
    panel.grid = element_blank(),
    plot.title = element_blank(),
    axis.text.y = element_text(hjust = 1),
    axis.text.x = element_blank()
  ) 




```

```{r SI_map_wexford_county, fig.show="hold", eval = TRUE, echo = FALSE, warning=FALSE, message=FALSE, cache=FALSE, fig.fullwidth = TRUE, ncol = 1, out.width="100%", fig.height = 2.5, fig.cap="Transit Supply across County Wexford, by Small Area"}


county_wexford_map <- ggplot()+ 
  geom_sf(data=si_wexford_250423_day_aggregated$si_by_area,
          aes(fill = transit_supply), colour=NA) +
  theme(axis.text.x=element_blank(), #remove x axis labels
        axis.ticks.x=element_blank(), #remove x axis ticks
        axis.text.y=element_blank(),  #remove y axis labels
        axis.ticks.y=element_blank(), #remove y axis ticks
        legend.position="none",
#        legend.text = element_text(size = 4), 
#        legend.title = element_text(size = 5), 
#        legend.key.size = unit(0.08, 'cm')
        ) + 
scale_fill_manual(values = c("Zero Supply" = "white", "Very Low" = "#F9D8B1", "Low" = "#F7C387", "Below average" = "#F29C33", "Above average" = "lightgreen", "High" = "#53A212", "Very High" = "darkgreen")) +
    coord_sf(xlim = c(lon[1],lon[2]), 
           ylim = c(lat[1], lat[2])) +
  ggspatial::annotation_scale(location = 'br') +
  ggspatial::annotation_north_arrow(location = 'tl') 
 


```



```{r wexford_social_needs, fig.dim=c(7.5,7.5), echo = FALSE, warning=FALSE, message=FALSE, cache=FALSE,  fig.fullwidth = FALSE,fig.cap="Wexford: Distribution of categories of social need index scores"}

wexford_centroids <- wexford %>% 
  select(SA_GUID_2022) %>% 
  st_centroid()

# Wexford post office is at 52.33856865371817, -6.460882271188064

df <- data.frame(
  lon = c(52.33856865371817),
  lat = c(-6.460882271188064)
)

wexford_post_office <- df %>% st_as_sf(coords = c("lon", "lat"), crs = 2157)

wexford$distance_m_to_GPO <- wexford_centroids %>% 
  st_distance(wexford_post_office) %>% 
  as.numeric()



#join to si data, including lat and long of each sa1
social_data_wexford <- inner_join(
  social_needs, 
  wexford %>% st_drop_geometry,
  by = join_by(guid == SA_GUID_2022))


#FUNCTION TO CALCULATE COMBINED NEEDS INDEX
#Comment out indicators we don't have
calculate_IRSAD_and_need_index <- function(social_dataset) {
 # scale all to 0 to 100
 # social_dataset$IRSAD_100 <- rescale_max(
#     social_dataset$IRSAD, to = c(0, 100))
#  social_dataset$adult_no_car_100 <- rescale_max(
#    social_dataset$adult_no_car, to = c(0, 100))
   social_dataset$accessibility_100 <- rescale_max(
     social_dataset$distance_m_to_GPO, to = c(0, 100))
   social_dataset$over_60_100 <- rescale_max(
     social_dataset$over_60, to = c(0, 100))
#   social_dataset$disability_pension_100 <- rescale_max(
#     social_dataset$disability_support_pension, to = c(0, 100))
#   social_dataset$low_income_families_100 <- rescale_max(
#     social_dataset$low_income_families, to = c(0, 100))
  social_dataset$adult_not_labour_force_100 <- rescale_max(
     social_dataset$adult_not_labour_force, to = c(0, 100))
  social_dataset$students_100 <- rescale_max(
     social_dataset$students, to = c(0, 100))
  social_dataset$age_five_to_nine_100 <- rescale_max(
     social_dataset$age_five_to_nine, to = c(0, 100))
  
  # calculate needs scores and scale to 100
  social_dataset$needs_score <- social_dataset$accessibility_100 * 0.15 + 
    social_dataset$over_60_100 * 0.14 + 
    social_dataset$adult_not_labour_force_100 * 0.09 + 
    social_dataset$students_100 * 0.09 + 
    social_dataset$age_five_to_nine_100 * 0.12
  
  social_dataset$needs_score_100 <- rescale_max(
     social_dataset$needs_score, to = c(0, 100))

  ### No IRSAD, so will only return the needs score based on the available transport indicators 
# weighted by population 
  
social_dataset$needs_score_100_population_weighted <- social_dataset$needs_score_100  *  social_dataset$population
  
#  social_dataset$total_need_IRSAD <- social_dataset$IRSAD *
#    social_dataset$population
#  social_dataset$total_transport_need <- social_dataset$needs_score * 
#    social_dataset$population
 
#  # create combined indicator 0 to 100
#  social_dataset$combined_needs_index <- social_dataset$total_need_IRSAD + 
#    social_dataset$total_transport_need 
#  social_dataset$combined_needs_index <- rescale_max(
#     social_dataset$combined_needs_index, to = c(0, 100))
  
social_dataset$combined_needs_index <- rescale_max(
     social_dataset$needs_score_100_population_weighted, to = c(0, 100))

  
  return(social_dataset %>% 
           select(guid, combined_needs_index, population)) 
}

needs_index_wexford <- calculate_IRSAD_and_need_index(
  social_data_wexford)

# Reuse the set thresholds function (but cheat by switching name of column two to SIs)
thresholds_holding <- needs_index_wexford %>%
  st_drop_geometry() %>% 
  select(guid, combined_needs_index) 

thresholds_holding$combined_needs_index <- thresholds_holding$combined_needs_index %>% unlist()

names(thresholds_holding) <- c("area_id", "SI")  

thresholds_holding <- set_thresholds(thresholds_holding)
names(thresholds_holding[[1]]) <- c("guid", "combined_needs_index", "composite_needs")
thresholds_holding[[1]]$composite_needs <- thresholds_holding[[1]]$composite_needs %>% fct_other(keep = c("Very Low", "Low", "Below average", "Above average", "High", "Very High"), other_level = "NA")

#join to guid geometry data
needs_index_wexford <- left_join(
  wexford %>%
    select(SA_GUID_2022),
  thresholds_holding[[1]], 
  by = join_by(SA_GUID_2022 == guid)
)



combined_needs_2021_plot <- ggplot()+ 
  geom_sf(data=needs_index_wexford %>% na.omit(),
          aes(fill =  composite_needs), colour=NA) +
  theme(axis.text.x=element_blank(), #remove x axis labels
        axis.ticks.x=element_blank(), #remove x axis ticks
        axis.text.y=element_blank(),  #remove y axis labels
        axis.ticks.y=element_blank(), #remove y axis ticks
        legend.position="none"
  ) +
    #    legend.text = element_text(size = 4), 
    #    legend.title = element_text(size = 5)) + 
  scale_fill_manual(values = c("#FFFB07", "#CEE102", "#A3CF07", "#61AE09", "#2EA105", "#0A7B01")) +
    ggspatial::annotation_scale(location = 'br') 

#combined_needs_2021_plot

```



```{r wexford_social_needs_population, fig.show="hold", eval = TRUE, echo = FALSE, warning=FALSE, message=FALSE, cache=FALSE, fig.margin = TRUE, fig.cap="Transit Supply across County Wexford, by population"}


#Set boundings box
bbox_list <- wexford %>% 
  st_geometry %>% 
  st_combine() %>%
  st_bbox()


lat = c(bbox_list["ymin"] %>% as.numeric(), bbox_list["ymax"] %>% as.numeric())
lon = c(bbox_list["xmin"] %>% as.numeric(), bbox_list["xmax"] %>% as.numeric() + 0*(bbox_list["xmax"] %>% as.numeric() - bbox_list["xmin"] %>% as.numeric()))

Poly_Coord_df = data.frame(lon, lat)

poly <- Poly_Coord_df %>% 
  st_as_sf(coords = c("lon", "lat"), 
           crs = 2157) %>% 
  st_bbox() %>% 
  st_as_sfc()

si_wexford_250423_day_aggregated$si_by_area <- left_join(
  si_wexford_250423_day_aggregated$si_by_area, 
  needs_index_wexford %>% 
    st_drop_geometry()
)

si_wexford_250423_day_aggregated$si_by_area$composite_needs <- 
  factor(si_wexford_250423_day_aggregated$si_by_area$composite_needs, 
            levels = c("Very Low", "Low", "Below average", "Above average", "High", "Very High"))
  

pcol_needs_wexford_county <- si_wexford_250423_day_aggregated$si_by_area %>%
  st_drop_geometry() %>%
  aggregate(population ~ composite_needs, sum) %>%
  right_join(tibble(composite_needs = si_wexford_250423_day_aggregated$si_by_area$composite_needs %>% levels())) %>%
  replace_na(list(population = 0)) %>%
  mutate(composite_needs=factor(composite_needs, levels = si_wexford_250423_day_aggregated$si_by_area$composite_needs %>% levels())) %>%
  arrange(composite_needs) %>%
  mutate(perc=population/sum(population)) %>% 
  na.omit() %>%
  ggplot() + 
  geom_col(aes(composite_needs, perc, fill = composite_needs), colour="black") +
  scale_y_continuous(limits = c(0,.6)) +
  geom_hline(yintercept = 0)  + 
  geom_text(aes(composite_needs,  0.5, label = glue::glue("{label_comma(accuracy = 1, big.mark = ",")(population)} ({label_percent(accuracy = 1)(perc)})"))) +
   coord_flip() + 
scale_fill_manual(values = c("Very Low" = "#FFFB07", "Low" = "#CEE102", "Below average" = "#A3CF07", "Above average" = "#61AE09", "High" = "#2EA105", "Very High" = "#0A7B01")) + 
  scale_color_manual(values = c(rep("black", 5), rep("white", 2), "black")) +
  guides(fill = "none", color = "none") +
  labs(
    title = "Transport need by population",
    x = NULL,
    y = NULL
  ) +
  theme_void() +
  theme(
    panel.grid = element_blank(),
    plot.title = element_blank(),
    axis.text.y = element_text(hjust = 1),
    axis.text.x = element_blank()
  ) 


#pcol_needs_wexford_county

```

  

```{r wexford_si_map, fig.show="hold", eval = TRUE, echo = FALSE, warning=FALSE, message=FALSE, cache=FALSE, fig.margin = TRUE, fig.cap="County Wexford: Small Area, by transit supply category"}

 county_wexford_map 
# +inset_element(pcol_si_wexford_county, left = 0.0, bottom = 0.8, right = 0.6, top =1.0) 


```

```{r wexford_si_pop_map, fig.show="hold", eval = TRUE, echo = FALSE, warning=FALSE, message=FALSE, cache=FALSE, fig.margin = TRUE, fig.cap="County Wexford: population living in Small Areas, by transit supply category"}

pcol_si_wexford_county

```

TRANSIT SUPPLY: Figure 1 shows Small Areas across County Wexford, categorised by transit supply, while Figure 2 summarises the share of the population living in Small Areas in each category. There are `r label_number(big.mark=",")(pcol_si_wexford_county$data[1:4,2] %>% sum())` people living in Small Areas with transit supply below the average across all Small Areas in County Wexford, representing some `r label_percent()(pcol_si_wexford_county$data[1:4,3] %>% sum())` of the total `r label_number(big.mark=",")(pcol_si_wexford_county$data[1:7,2] %>% sum())` population. This includes the `r label_number(big.mark=",")(pcol_si_wexford_county$data[1,2] %>% sum())` people (`r label_percent()(pcol_si_wexford_county$data[1,3] %>% sum())`) living in Small Areas with no transit supply at all, which mostly appear to be in rural areas. 

In general, most of the transit supply appears to be provided within the various centres of population. Table 1 shows the population in each Transit Supply category for the various urban areas in County Wexford, shown in order of population. As might be expected, those places with larger populations tend to have more transit supplied, but this appears to apply only in general terms. Notably, New Ross, Courttown, Rosslare Harbour and Castlebridge do not have any Small Areas with Very High transit supply, and the later three do not have any with High supply either.  Rosslare itself, however has some Small Areas with High and Very High transit supply, despite having fewer residents.



```{r wexford_si_by_urban_area, fig.show="hold", eval = TRUE, echo = FALSE, warning=FALSE, message=FALSE, cache=FALSE, fig.fullwidth = TRUE, ncol= 2, out.width="50%", fig.cap="County Wexford: transit supply (left) and social need for transport (right) by Small Area"}


wexford_small_area_supply_by_urban_area <- si_wexford_250423_day_aggregated$si_by_area %>% 
  st_drop_geometry() %>%
  select(transit_supply, population, SA_URBAN_AREA_NAME) %>%
  aggregate(population ~ transit_supply +  SA_URBAN_AREA_NAME , sum)

wexford_small_area_supply_by_urban_area_table <- wexford_small_area_supply_by_urban_area %>% 
  pivot_wider(names_from = transit_supply, values_from = population) %>%
  mutate_all(~replace(., is.na(.), 0)) 
  
wexford_small_area_supply_by_urban_area_table$total <- wexford_small_area_supply_by_urban_area_table[,2:8] %>% rowSums()


wexford_small_area_supply_by_urban_area_table <- wexford_small_area_supply_by_urban_area_table[order(wexford_small_area_supply_by_urban_area_table$total, decreasing = TRUE),]

wexford_small_area_supply_by_urban_area_table <- wexford_small_area_supply_by_urban_area_table [,1:8]

wexford_small_area_supply_by_urban_area_table %>% 
  adorn_totals(where = c("row","col")) %>%
  adorn_percentages(denominator = "row") %>%
  adorn_pct_formatting() %>% 
  adorn_ns() %>% 
  select(SA_URBAN_AREA_NAME, `Zero Supply`, `Very Low`, Low, `Below average`,`Above average`, `High`, `Very High`, Total) %>%
  kable(align = "lrrrrrrrr", 
        caption = "County Wexford: urban populations in each Transit Supply grouping",
        col.names = c("Urban area", 
                    "Zero Supply", "Very Low", "Low",
                    "Below average", "Above average", 
                    "High", "Very High",
                  "Total")) %>% 
  add_header_above(c(" " = 1, "Transit Supply category" = 7, " " = 1)) %>%
  kable_styling(font_size = 8) %>%
  kableExtra::column_spec(1, width = "1.50cm") %>% 
  kableExtra::column_spec(2, width = "1.65cm") %>%
  kableExtra::column_spec(3, width = "1.45cm") %>%
  kableExtra::column_spec(4, width = "1.65cm") %>%
  kableExtra::column_spec(5, width = "1.65cm") %>%
  kableExtra::column_spec(6, width = "1.65cm")  %>%
  kableExtra::column_spec(7, width = "1.65cm") %>%
  kableExtra::column_spec(8, width = "1.65cm") %>% 
  kableExtra::column_spec(9, width = "2cm") 

```
 


```{r wexford_needs_map, fig.show="hold", eval = TRUE, echo = FALSE, warning=FALSE, message=FALSE, cache=FALSE, fig.margin = TRUE, fig.cap="County Wexford: Small Area, by social need for transport category"}

 combined_needs_2021_plot


```

```{r wexford_needs_pop_map, fig.show="hold", eval = TRUE, echo = FALSE, warning=FALSE, message=FALSE, cache=FALSE, fig.margin = TRUE, fig.cap="County Wexford: population living in Small Areas, by social need for transport category"}

pcol_needs_wexford_county

```
 
 
Further down the list, Ferns appears to have more transit supply than might be expected for its population, while Kilmuchridge, Ballymurn, Coolgreany, Ballysimon, Adamstown and Killinierin have no transit at all despite their populations being higher than many places that do have at least some transit. 

SOCIAL NEEDS FOR TRANSPORT:

Figure 3 shows Small Areas across County Wexford, categorised by social need for transport, while Figure 4 shows the population living in Small Areas in each category. There are `r label_number(big.mark=",")(pcol_needs_wexford_county$data[4:6,2] %>% sum())` people living in Small Areas that have above the average score (across all Small Areas in County Wexford) for social needs for transport, representing some `r label_percent()(pcol_needs_wexford_county$data[4:6,3] %>% sum())` of the total popluation (`r label_number(big.mark=",")(pcol_needs_wexford_county$data[1:6,2] %>% sum())`). This includes the `r label_number(big.mark=",")(pcol_needs_wexford_county$data[6,2] %>% sum())` people (`r label_percent()(pcol_needs_wexford_county$data[6,3] %>% sum())`) living in Small Areas with Very High social needs for transport. 




```{r wexford_needs, fig.show="hold", eval = FALSE, echo = FALSE, warning=FALSE, message=FALSE, cache=FALSE, fig.fullwidth = FALSE, fig.cap="County Wexford: social need for transport categories by Small Area"}


combined_needs_2021_plot + 
    inset_element(pcol_needs_wexford_county, left = 0.0, bottom = 0.8, right = 0.6, top =1.0) 


```

NEEDS-GAP:

Table 2 shows the share of the County Wexford population living in Small Areas with each combination of the transit supply and social need for transport categories. Figure 3 maps the Small Areas by each combination, with those that have similar needs-gaps shown using the same colours, as shown in Table 2. 


```{r Wexford_needs_gap_population, fig.show="hold", eval = TRUE, echo = FALSE, warning=FALSE, message=FALSE, cache=FALSE, fig.fullwidth = TRUE, fig.cap="County Wexford, Populations within each SI and Combined Needs Index grouping"}



wexford_small_area_need_gap_population_crosstable_2021 <- si_wexford_250423_day_aggregated$si_by_area %>% 
  st_drop_geometry() %>%
  aggregate(population ~ transit_supply + composite_needs, sum)


wexford_small_area_need_gap_population_crosstable_plot <- wexford_small_area_need_gap_population_crosstable_2021 %>% 
  pivot_wider(names_from = composite_needs, values_from = population) %>%
  adorn_totals(where = c("row", "col")) %>%
  adorn_percentages(denominator = "col") %>%
  adorn_pct_formatting() %>% 
  adorn_ns() %>% 
  select(transit_supply, `Very High`, `High`, `Above average`, `Below average`, Low, `Very Low`, Total) %>%
  kable(align = "lrrrrrrr", 
        caption = "County Wexford, population in each Transit Supply and Combined Needs grouping",
        col.names = c("Supply", 
                   "Very High", "High", 
                   "Above average", "Below average",
                   "Low", "Very Low", "Total")) %>% 
  add_header_above(c(" " = 1, "Combined Needs Index Category" = 6, " " = 1)) %>%
  kable_styling(font_size = 8) %>%
  kableExtra::column_spec(1, width = "2.5cm") %>% 
  kableExtra::column_spec(2, width = "1.25cm", background = c("#a50026", "#d73027", "#f46d43", "#fdae61", 
"#fee090","#ffffbf", "#e0f3f8","#ffffff"), color = c("white", "white", "white", "black", "black", "black", "black", "black")) %>%
  kableExtra::column_spec(3, width = "1.25cm" , background = c("#d73027", "#f46d43", "#fdae61", 
"#fee090","#ffffbf", "#e0f3f8", "#abd9e9" ,"#ffffff"), color = c("white", "white", "black", "black", "black", "black", "black", "black")) %>%
  kableExtra::column_spec(4, width = "1.25cm", background = c("#f46d43", "#fdae61", 
"#fee090","#ffffbf", "#e0f3f8", "#abd9e9","#74add1","#ffffff"), color = c("white", "black", "black", "black", "black", "black", "black", "black")) %>%
  kableExtra::column_spec(5, width = "1.25cm", background = c("#fdae61", 
"#fee090","#ffffbf", "#e0f3f8", "#abd9e9","#74add1","#4575b4", "#ffffff"), color = c("black", "black", "black", "black", "black", "black", "white", "black")) %>%
  kableExtra::column_spec(6, width = "1.25cm", background = c("#fee090","#ffffbf", "#e0f3f8", "#abd9e9","#74add1","#4575b4", "#313695", "#ffffff"), color = c("black", "black", "black", "black", "black", "white", "white", "black"))  %>%
  kableExtra::column_spec(7, width = "1.25cm", background = c("#ffffbf", "#e0f3f8", "#abd9e9","#74add1","#4575b4", "#313695", "purple", "#ffffff"), color = c("black", "black", "black", "black", "white", "white", "white", "black")) %>%
  kableExtra::column_spec(8, width = "1.25cm")

wexford_small_area_need_gap_population_crosstable_2021$composite_needs <- factor(
  wexford_small_area_need_gap_population_crosstable_2021$composite_needs, 
  levels = c("Very Low", "Low", "Below average", "Above average", "High", "Very High"))
wexford_small_area_need_gap_population_crosstable_2021$transit_supply <- factor(
  wexford_small_area_need_gap_population_crosstable_2021$transit_supply, 
  levels = c("Zero Supply", "Very Low", "Low", "Below average", "Above average", "High", "Very High"))


wexford_small_area_need_gap_population_crosstable_2021_plot <- wexford_small_area_need_gap_population_crosstable_2021 %>%
    ggbarstats(x = transit_supply, 
             y = composite_needs, 
             counts = "population"
             ) + 
  scale_fill_manual(values = c("Very High" = "darkgreen",
                               "High" = "#53A212", 
                               "Above average" = "lightgreen", 
                               "Below average" = "#F29C33",
                               "Low" = "#F7C387", 
                               "Very Low" = "#F9D8B1", 
                               "Zero Supply" = "#FFFFFF" )) +  
                                 theme(legend.position="bottom")

#wexford_small_area_need_gap_population_crosstable_2021_plot
  

### Calculate by Small Area to allow statistical tests

wexford_small_area_need_gap_zone_crosstable_2021 <-  si_wexford_250423_day_aggregated$si_by_area %>% 
  st_drop_geometry() %>%
  tabyl(transit_supply,composite_needs) %>% 
  untabyl() %>% 
  select(transit_supply, `Very Low`, Low, `Below average`, `Above average`, High, `Very High`)

wexford_small_area_need_gap_zone_crosstable_2021_test <- wexford_small_area_need_gap_zone_crosstable_2021[,2:7] %>%
  chisq.test()

#wexford_small_area_need_gap_zone_crosstable_2021_test$expected
# all values over 5, assumptions met. 

```

Differences in the share of Small Areas in each transit supply category across the different social need for transport groups were statistically significant (`r prmisc::print_chi2(wexford_small_area_need_gap_zone_crosstable_2021_test)`). In general, those living in Small Areas with higher social needs for transit appeared to be more likely to also have lower levels of transit supply. For example, 
`r label_percent()(wexford_small_area_need_gap_population_crosstable_2021[36:39,3] %>% sum() / wexford_small_area_need_gap_population_crosstable_2021[36:42,3] %>% sum())` of those living in Small Areas with Very High social needs for transport had below average transit supplies, compared to just `r label_percent()(wexford_small_area_need_gap_population_crosstable_2021[1:4,3] %>% sum() / wexford_small_area_need_gap_population_crosstable_2021[1:7,3] %>% sum())` of those living in Small Areas with Very Low social needs for transport. Out of the total `r wexford_small_area_need_gap_population_crosstable_2021[,3] %>% sum() %>% label_number(big.mark = ",")()` population of County Wexford, some `r sum(wexford_small_area_need_gap_population_crosstable_2021[36,3], wexford_small_area_need_gap_population_crosstable_2021[29,3], wexford_small_area_need_gap_population_crosstable_2021[22,3]) %>% label_number(big.mark = ",")()` (`r label_percent()(sum(wexford_small_area_need_gap_population_crosstable_2021[36,3], wexford_small_area_need_gap_population_crosstable_2021[29,3], wexford_small_area_need_gap_population_crosstable_2021[22,3]) / (wexford_small_area_need_gap_population_crosstable_2021[,3] %>% sum()))`) live in Small Areas with social needs for transport that are above the County average, but where there is no transit supply at all.  

\newpage

```{r Wexford_needs_gap_map_graphs_needs, fig.show="hold", eval = TRUE, echo = FALSE, warning=FALSE, message=FALSE, cache=FALSE, fig.fullwidth = TRUE, fig.cap="County Wexford, Needs-gap by population, split by social needs for transport category"}

wexford_small_area_need_gap_population_crosstable_plot

```


```{r Wexford_needs_gap_map_graphs, fig.show="hold", eval = TRUE, echo = FALSE, warning=FALSE, message=FALSE, cache=FALSE, fig.margin = TRUE, fig.cap="County Wexford, Needs-gap by Small Area"}

#combine (cross) transit supply and social needs factors.
 si_wexford_250423_day_aggregated$si_by_area$gap_colour <- fct_cross(si_wexford_250423_day_aggregated$si_by_area$transit_supply, si_wexford_250423_day_aggregated$si_by_area$composite_needs)

#combine colour cells
si_wexford_250423_day_aggregated$si_by_area$gap_colour <- si_wexford_250423_day_aggregated$si_by_area$gap_colour %>% fct_collapse(b = c("Zero Supply:High", "Very Low:Very High"))

si_wexford_250423_day_aggregated$si_by_area$gap_colour <- si_wexford_250423_day_aggregated$si_by_area$gap_colour %>% fct_collapse(c = c("Zero Supply:Above average", "Very Low:High", "Low:Very High"))

si_wexford_250423_day_aggregated$si_by_area$gap_colour <- si_wexford_250423_day_aggregated$si_by_area$gap_colour %>% fct_collapse(d = c("Zero Supply:Below average", "Very Low:Above average", "Low:High", "Below average:Very High"))

si_wexford_250423_day_aggregated$si_by_area$gap_colour <- si_wexford_250423_day_aggregated$si_by_area$gap_colour %>% fct_collapse(d = c("Zero Supply:Below average", "Very Low:Above average", "Low:High", "Below average:Very High"))                                                                                                                                  
si_wexford_250423_day_aggregated$si_by_area$gap_colour <- si_wexford_250423_day_aggregated$si_by_area$gap_colour %>% fct_collapse(e = c("Zero Supply:Low", "Very Low:Below average", "Low:Above average", "Below average:High", "Above average:Very High"))                                                                                                                                  
si_wexford_250423_day_aggregated$si_by_area$gap_colour <- si_wexford_250423_day_aggregated$si_by_area$gap_colour %>% fct_collapse(f = c("Zero Supply:Very Low", "Very Low:Low", "Low:Below average", "Below average:Above average", "Above average:High", "High:Very High"))                                            

si_wexford_250423_day_aggregated$si_by_area$gap_colour <- si_wexford_250423_day_aggregated$si_by_area$gap_colour %>% fct_collapse(g = c("Very Low:Very Low", "Low:Low", "Below average:Below average", "Above average:Above average", "High:High", "Very High:Very High"))                                                                                                                                    
si_wexford_250423_day_aggregated$si_by_area$gap_colour <- si_wexford_250423_day_aggregated$si_by_area$gap_colour %>% fct_collapse(h = c("Low:Very Low", "Below average:Low", "Above average:Below average", "High:Above average", "Very High:High"))                                                                                                                                                                                                                                                                      


si_wexford_250423_day_aggregated$si_by_area$gap_colour <- si_wexford_250423_day_aggregated$si_by_area$gap_colour %>% fct_collapse(i = c("Below average:Very Low", "Above average:Low", "High:Below average", "Very High:Above average"))                                                                                                                                  
si_wexford_250423_day_aggregated$si_by_area$gap_colour <- si_wexford_250423_day_aggregated$si_by_area$gap_colour %>% fct_collapse(j = c("Above average:Very Low", "High:Low", "Very High:Below average"))                                                                                                                               
                                                                                                                                  
si_wexford_250423_day_aggregated$si_by_area$gap_colour <- si_wexford_250423_day_aggregated$si_by_area$gap_colour %>% fct_collapse(k = c("High:Very Low", "Very High:Low"))                                                                                                                                 
   
si_wexford_250423_day_aggregated$si_by_area$gap_colour <- si_wexford_250423_day_aggregated$si_by_area$gap_colour  %>% fct_recode(a = "Zero Supply:Very High", l = "Very High:Very Low")

si_wexford_250423_day_aggregated$si_by_area$gap_colour <- si_wexford_250423_day_aggregated$si_by_area$gap_colour %>% fct_relevel(c("a", "b", "c", "d","e", "f", "g", "h", "i", "j", "k", "l"))




needs_gap_plot <- ggplot()+ 
  geom_sf(data=si_wexford_250423_day_aggregated$si_by_area,
          aes(fill =  gap_colour), colour=NA) +
  theme(axis.text.x=element_blank(), #remove x axis labels
        axis.ticks.x=element_blank(), #remove x axis ticks
        axis.text.y=element_blank(),  #remove y axis labels
        axis.ticks.y=element_blank(), #remove y axis ticks
        legend.position="none"
  ) +
    #    legend.text = element_text(size = 4), 
    #    legend.title = element_text(size = 5)) + 
  scale_fill_manual(values = c(a = "#a50026", b = "#d73027", c ="#f46d43", d="#fdae61", e="#fee090", f="#ffffbf", g="#e0f3f8", h="#abd9e9", i= "#74add1", j="#4575b4", k="#313695", l="purple")) +
    ggspatial::annotation_scale(location = 'br') 


wexford_small_area_need_gap_population_crosstable_2021_sum_by_gap_colour <- si_wexford_250423_day_aggregated$si_by_area %>% 
  st_drop_geometry() %>%
  aggregate(population ~ gap_colour, sum)


pcol_needs_gap_wexford_county <- si_wexford_250423_day_aggregated$si_by_area %>%
  st_drop_geometry() %>%
  aggregate(population ~ gap_colour, sum) %>%
  right_join(tibble(gap_colour = si_wexford_250423_day_aggregated$si_by_area$gap_colour %>% levels())) %>%
  replace_na(list(population = 0)) %>%
  mutate(gap_colour=factor(gap_colour, levels = si_wexford_250423_day_aggregated$si_by_area$gap_colour %>% fct_rev() %>% levels())) %>%
  arrange(gap_colour) %>%
  mutate(perc=population/sum(population)) %>% 
  na.omit() %>%
  ggplot() + 
  geom_col(aes(gap_colour, perc, fill = gap_colour), colour="black") +
  scale_y_continuous(limits = c(0,.2)) +
  geom_hline(yintercept = 0)  + 
  geom_text(aes(gap_colour,  0.15, label = glue::glue("{label_comma(accuracy = 1, big.mark = ",")(population)} ({label_percent(accuracy = 1)(perc)})"))) +
   coord_flip() + 
 scale_fill_manual(values = c(a = "#a50026", b = "#d73027", c ="#f46d43", d="#fdae61", e="#fee090", f="#ffffbf", g="#e0f3f8", h="#abd9e9", i= "#74add1", j="#4575b4", k="#313695", l="purple")) +
  scale_color_manual(values = c(rep("black", 5), rep("white", 2), "black")) +
  guides(fill = "none", color = "none") +
  labs(
    title = "Needs-gap by population",
    x = NULL,
    y = NULL
  ) +
  theme_void() +
  theme(
    panel.grid = element_blank(),
    plot.title = element_blank(),
    axis.text.y = element_blank(),
    axis.text.x = element_blank()
  ) 

#needs_gap_plot + 
#    inset_element(pcol_needs_gap_wexford_county, left = 0.0, bottom = 0.8, right = 0.6, top =1.0) 


plot_population_by_color_group_by_needs <-  function(df=df, needs_category=needs_category) {
  df %>%
  st_drop_geometry() %>%
  filter(composite_needs == needs_category) %>%
  aggregate(population ~ gap_colour, sum) %>%
  right_join(tibble(gap_colour = df$gap_colour %>% levels())) %>%
  replace_na(list(population = 0)) %>%
  mutate(gap_colour=factor(gap_colour, levels = df$gap_colour %>% fct_rev() %>% levels())) %>%
  arrange(gap_colour) %>%
  mutate(perc=population/sum(population)) %>% 
  na.omit() %>%
  ggplot() + 
  geom_col(aes(gap_colour, perc, fill = gap_colour), colour="black") +
  scale_y_continuous(limits = c(0,.6)) +
  geom_hline(yintercept = 0)  + 
  geom_text(aes(gap_colour,  0.5, label = glue::glue("{label_comma(accuracy = 1, big.mark = ",")(population)} ({label_percent(accuracy = 1)(perc)})")), size = 1.5) +
   coord_flip() + 
 scale_fill_manual(values = c(a = "#a50026", b = "#d73027", c ="#f46d43", d="#fdae61", e="#fee090", f="#ffffbf", g="#e0f3f8", h="#abd9e9", i= "#74add1", j="#4575b4", k="#313695", l="purple")) +
  scale_color_manual(values = c(rep("black", 5), rep("white", 2), "black")) +
  guides(fill = "none", color = "none") +
  labs(
    title = needs_category,
    x = NULL,
    y = NULL
  ) +
  theme_void() +
  theme(
    panel.grid = element_blank(),
    plot.title = element_blank(),
    axis.text.y = element_blank(),
    axis.text.x = element_blank()
  ) 
}
very_high_needs_plot <- plot_population_by_color_group_by_needs(df=si_wexford_250423_day_aggregated$si_by_area, needs_category = "Very High")

high_needs_plot <- plot_population_by_color_group_by_needs(df=si_wexford_250423_day_aggregated$si_by_area, needs_category = "High")

above_average_needs_plot <- plot_population_by_color_group_by_needs(df=si_wexford_250423_day_aggregated$si_by_area, needs_category = "Above average")

below_average_needs_plot <- plot_population_by_color_group_by_needs(df=si_wexford_250423_day_aggregated$si_by_area, needs_category = "Below average")

low_needs_plot <- plot_population_by_color_group_by_needs(df=si_wexford_250423_day_aggregated$si_by_area, needs_category = "Low")

very_low_needs_plot <- plot_population_by_color_group_by_needs(df=si_wexford_250423_day_aggregated$si_by_area, needs_category = "Very Low")

needs_gap_plot 
#+
#    inset_element(pcol_needs_gap_wexford_county, left = 0.0, bottom = 0.7, right = 0.5, top =1.0) 

```

```{r Wexford_needs_gap_map_population_graph, fig.show="hold", eval = TRUE, echo = FALSE, warning=FALSE, message=FALSE, cache=FALSE, fig.margin = TRUE, fig.cap="County Wexford, population living in Small Areas, by needs-gap grouping"}
pcol_needs_gap_wexford_county

```




