---
title: "Social needs for transport and gaps in transit service: Enniscorthy, Ireland"
runningheader: "Enniscorthy, Ireland Division:needs-gaps" # only for pdf output
author: "Dr James Reynolds"
date: "`r Sys.Date()`"
bibliography: References.bib
csl: https://www.zotero.org/styles/chicago-fullnote-bibliography-16th-edition
suppress-bibliography: yes
output:
#  tufte::tufte_html: default
  tufte::tufte_handout:
#    citation_package: natbib
#    latex_engine: xelatex
#  tufte::tufte_book:
#    citation_package: natbib
#    latex_engine: xelatex

---

```{r setup, include=FALSE}
library(tidyverse)
library(tidytransit)
library(sp)
library(strayr)
library(ptinpoly)
library(magrittr)
library(ggplot2)
library(sf)
library(ASGS.foyer)
library(raster)
library(ggmap)
library(units)
library(janitor)
library(mapview)
library(ggstatsplot)
library(gtsummary)
library(moments)
library(scales)
library(gtfstools)
library(lubridate)
library(kableExtra)
library(knitr)
library(readxl)
library(readr)
library(dplyr)
library(devtools)
library(gtfssupplyindex)
library(readabs)
library(gglorenz)
library(DescTools)
library(RColorBrewer)
library(lsr)
library(ggpubr)
library(viridis)
library(geosphere)
library(png)
library(absmapsdata)
library(tidytransit)
library(patchwork)

knitr::opts_chunk$set(warning = FALSE, message = FALSE) 

```

# Introduction
The CONUNDRUM project relates to sustainable transport,
community mobility 
and co-creation,
and is using Enniscorthy 
in County Wexford, Ireland, 
as a test bed. 
However, 
assessments and mapping of 
social needs for transport, 
and public transport supply 
provided in Enniscorthy, 
and how these compare to other places in Ireland, 
do not appear to be publically available.  
Currie et al[@Currie2003Hobart, @Currie2004Gap; @Currie2007Identifying, @currie2010identifying] 
developed a methodology for assessing 
spatial gaps between social needs 
and transit supply 
An R package^[See
https://github.com/James-Reynolds/gtfssupplyindex] 
has recently been developed 
that facilitates 
the calculation of the 
transit supply levels 
from General Transit Feed Specification (GTFS) 
datasets. 

This note presents results 
obtained by applying 
the gtfssupply index R package 
to Ireland's GTFS dataset,  
with an emphasis on Enniscorthy 
in county Wexford.


# Background

## Transit supply
The social needs-gap 
analysis methodology
involves calculating 
a Supply Index (SI) 
based on the 
number of transit service arrivals 
at stops in and around 
each area of interest. 
Adjustments are made 
for the amount of 
each area 
that is within 
a typical walking distance 
of each stop, 
according to the following 
formula: 

$$SI_{area, time} = \sum{\frac{Area_{Bn}}{Area_{area}}SL_{n, time}}$$

where:

-   $SI_{area, time}$ is the Supply Index for the area of interest and a given period of time;

-   $Area_{Bn}$ is the buffer area for each stop (n) within the area of interest^[In @currie2010identifying this was based on a radius of 400 metres for bus and tram stops, and 800 metres for railway stations. The same definition is used here.];

-   $Area_{area}$ is the area of the area of interest; and

-   $SL_{n,time}$ is the number of transit arrivals for each stop within the given time period.

As such, 
the SI combines
coverage (accessibility to transit) 
and service frequency (accibility by transit). The 
SI is a relative index, 
allowing comparison between 
different areas of interest, 
based on transit supplied over a 
specific time period. In the results reported in 
@currie2010identifying 
transit supply was 
assessed based on 
an entire week, 
and compared across 
Census Collection Districts (CCDs)
within Greater Melbourne. 
CCDs were clasify into 
seven groups 
based on SI scores^[ 
being those with: 
zero supply; 
very low, 
low, 
or below average supply; 
and above average, 
high 
or very high supply.  
CCDs with above and below average
SIs were evenly split into each of the 
three sub-groups, respectively.]. 

## Transport needs
Transport needs were similarly 
assessed using a index score, 
based on various metrics
available from the Australian Bureau of Statistics (ABS). 
These included 
the Index of Relative Socio-Economic Advantage/Disadvantage (IRSAD), 
which is reported directly 
by the ABS 
based on 31 weighted indicators 
and data collected during the census. A transport-specific need index, 
based on eight weighted indicators^[Adults without cars (0.19), 
distance to the Melbourne Central Business District (0.15), 
persons aged over 60 years (0.14), 
persons on a disability pension (0.12), 
low income households (0.10), 
adults not in the labour force (0.09), 
students (0.09) and 
persons 5-9 years (0.12).] 
was also included, 
with scores 
categorised based on 
three groups below 
and three groups above 
the average score across all of Melbourne.  

Clearly, 
the approach used to assess
social needs for transport 
might need to be adjusted 
to reflect different data availability 
in different locations 
or from different editions of a census.  

## Needs-gaps

The final step was to compare 
social needs for transport 
with 
the amount of transit 
supplied 
in each area of interest. A key finding was that 
"8.2% of Melbourne residents ha(d) ‘very high’ needs but
‘zero’, ‘low’ or ‘very low’ public transport supply", 
reflective of 
areas of greater need 
often being in places 
on urban fringes 
or otherwise often remote from 
transit infrastructure and services.  
More broadly, it was suggested that 
the developed methodology 
might be "substantially more useful than the presentation of
anecdotal evidence which is the most common means 
of identifying transport needs in local transport studies throughout the
world``[@currie2010identifying].

# Methodology
# Supply Index

This analysis used the all-Ireland GTFS 
dataset, downloaded on April 23, 2025 
and reporting scores for transit services 
provided on that same date (the first Wednesday after Easter). The "Small Area" National Statistical Boundaries from 2022 
were adopted as the areas of interest, 
with the indexing of supply based on 
the average score across the County of Wexford.  


```{r load_ireland_gtfs, eval = FALSE, echo = FALSE}

ireland_250423 <- tidytransit::read_gtfs("data/GTFS_All.zip")

## convert to list of tidygtfs objects
ireland_250423_list_gtfs <- gtfssupplyindex::gtfs_by_route_type("data/GTFS_All.zip")


```

```{r run_for_all_modes_ireland_, eval = FALSE, echo = FALSE}

list_gtfs = ireland_250423_list_gtfs


Small_Area_National_Statistical_Boundaries_2022 <- st_read("data/Small_Area_National_Statistical_Boundaries_2022_Ungeneralised_view_-7354763930310470674.gpkg")
st_geometry(Small_Area_National_Statistical_Boundaries_2022) <- "SHAPE"

wexford <- Small_Area_National_Statistical_Boundaries_2022 %>% 
  filter(COUNTY_ENGLISH == "WEXFORD") %>%
  select(SA_PUB2022)

names(wexford) <- c("sa_pub2022", "geometry")
wexford <- st_set_geometry(wexford, "geometry")


#Load Wexford codes
areas_of_interest <- load_areas_of_interest(wexford,  
  area_id_field = "sa_pub2022")


stops_in_or_near_areas <- gtfssupplyindex:::stops_in_walk_dist(
  list_gtfs = list_gtfs, 
  areas_of_interest = areas_of_interest,
  EPSG_for_transform = 2157,
  verbose = FALSE
)



si_wexford_250423_day <- SI_by_day_hour_and_route_type(
     list_gtfs = list_gtfs, 
stops_in_or_near_areas = stops_in_or_near_areas,
 start_date_ymd = "2025-04-23", 
 end_date_ymd = "2025-04-23",
verbose = TRUE)

write.csv(si_wexford_250423_day, "results/si_wexford_250423_day")


si_wexford_250423_day_aggregated <- si_wexford_250423_day %>% 
           group_by(area_id) %>%    
           summarize(SI = sum(SI))

write.csv(si_wexford_250423_day_aggregated, "results/si_wexford_250423_day_aggregated.csv")


```


## Needs

```{r read_ABS_data_2021, fig.show="hold", eval= FALSE, echo = FALSE, warning=FALSE, message=FALSE, cache=TRUE, fig.fullwidth = TRUE, fig.cap="SI scores by SA3, census day 2016 and 2021"}

#read IRSAD 2021 and remove non-data rows
sa1_irsad_2021 <- read_excel("data/Statistical Area Level 1, Indexes, SEIFA 2021.xlsx", 
    sheet = "Table 3", skip = 5)
sa1_irsad_2021 <- sa1_irsad_2021 %>% filter(row_number() <= n()-3)
sa1_irsad_2021 <- sa1_irsad_2021 %>% 
  clean_names()

#read students 2021 and remove non-data rows
sa1_students_2021 <- read_csv("data/sa1_students.csv", 
    skip = 8)
sa1_students_2021 <- sa1_students_2021[-1,]
sa1_students_2021 <- sa1_students_2021 %>% filter(row_number() <= n()-5)

#read not in labour force in 2021 and remove non-data rows
#this dataset contains a single 'wafer', 
# being those people not in the labour force, separated by age and sa1
sa1_not_in_labour_force_2021 <- read_csv("data/sa1_not_in_labour_force_2021.csv", 
    skip = 10)
sa1_not_in_labour_force_2021 <- sa1_not_in_labour_force_2021[-1,]
#not_in_labour_force csv from ABS repeats the entire dataset, hence only read in first set
sa1_not_in_labour_force_2021 <- sa1_not_in_labour_force_2021 %>% filter(row_number() <= n()-61844)


#calculate number of adults not in labour force (ie 18+)
sa1_not_in_labour_force_2021$adult_not_labour_force <- rowSums (sa1_not_in_labour_force_2021[,20:117])
  

#read no car in 2021 and remove non-data rows
#this dataset contains a single 'wafer', 
# being those people living in a household with no car, separated by age and sa1
sa1_no_car_2021 <- read_csv("data/sa1_no_car_2021.csv", 
    skip = 8)
sa1_no_car_2021 <- sa1_no_car_2021[-1,]
sa1_no_car_2021 <- sa1_no_car_2021 %>% filter(row_number() <= n()-5)
#calculate number of adults with no car (ie 18+)
sa1_no_car_2021$adult_no_car <- rowSums(sa1_no_car_2021[,20:117])


#read low income in 2021 and remove non-data rows
sa1_low_income_2021 <- read_csv("data/sa1_low_income.csv", 
    skip = 8)
sa1_low_income_2021 <- sa1_low_income_2021[-1,]
sa1_low_income_2021 <- sa1_low_income_2021 %>% filter(row_number() <= n()-5)

#read disability support pension in 2021 and remove non-data rows
sa1_disability_support_pension_2021 <- read_csv("data/sa1_disability_2021.csv", 
    skip = 8)
sa1_disability_support_pension_2021 <- sa1_disability_support_pension_2021[-1,]
sa1_disability_support_pension_2021 <- sa1_disability_support_pension_2021 %>% filter(row_number() <= n()-5)


#read age in 2021 and remove non-data rows
sa1_age_2021 <- read_csv("data/sa1_age.csv", 
    skip = 8)
sa1_age_2021 <- sa1_age_2021[-1,]
sa1_age_2021 <- sa1_age_2021 %>% filter(row_number() <= n()-5)

#calculate number of people over 60.
sa1_age_2021$over_60 <- rowSums(sa1_age_2021[,63:117])

#calculate number of persons 5 to 9 years old.
sa1_age_2021$persons_5_to_9 <- rowSums(sa1_age_2021[,7:11]) 
#move age-related indicators into social indicators table. 
social_2021_sa1 <- sa1_age_2021 %>% 
  select(`AGEP Age`, over_60, persons_5_to_9)
names(social_2021_sa1) <- c("sa1_code_2021", "over_60", "five_to_nine")

#join Adults without Cars
social_2021_sa1 <- full_join(social_2021_sa1, 
                             sa1_no_car_2021 %>% 
                               select("AGEP Age", "adult_no_car"), 
                             by = join_by( "sa1_code_2021" == "AGEP Age"))

#join disability pension 
sa1_disability_support_pension_2021 <-  sa1_disability_support_pension_2021 %>% 
  clean_names()
  
social_2021_sa1 <- full_join(social_2021_sa1, 
                             sa1_disability_support_pension_2021 %>% 
                               select(
                                 "igap_main_type_of_personal_government_benefit_payment_administrative_data", 
                                      "disability_support_pension"),
                             by = join_by(
                               "sa1_code_2021" == "igap_main_type_of_personal_government_benefit_payment_administrative_data"))



#join low income households
sa1_low_income_2021$low_income_families <- rowSums(sa1_low_income_2021[,2:9])
social_2021_sa1 <- full_join(social_2021_sa1, 
                             sa1_low_income_2021 %>% 
                               select("FINASF Total Family Income as Stated (weekly)", "low_income_families"), 
                             by = join_by( "sa1_code_2021" == "FINASF Total Family Income as Stated (weekly)"))


#join adults not in labour force
social_2021_sa1 <- full_join(social_2021_sa1 %>% na.omit(), 
                             sa1_not_in_labour_force_2021 %>% 
                               select("AGEP Age", "adult_not_labour_force") %>%
                               na.omit(), 
                             by = join_by("sa1_code_2021" == "AGEP Age"))

#join students
sa1_students_2021$students <- sa1_students_2021$Total
social_2021_sa1 <- full_join(social_2021_sa1, 
                             sa1_students_2021 %>% 
                               select("STUP Full-Time/Part-Time Student Status", "students"), 
                             by = join_by( "sa1_code_2021" == "STUP Full-Time/Part-Time Student Status"))

#join IRSAD scores
sa1_irsad_2021$x2021_statistical_area_level_1_sa1 <- sa1_irsad_2021$x2021_statistical_area_level_1_sa1 %>% 
  as.character()
names(sa1_irsad_2021) <- c("sa1_code_2021", 
                           "usual_resident_population",
                           "IRSAD", 
                           "x4", 
                           "rank_in_australia", 
                           "decile_in_australia",
                           "percentile_in_australia", 
                           "x8", 
                           "state", 
                           "rank_in_state",
                           "decile_in_state",
                           "percentile_in_state")

social_2021_sa1 <- full_join(social_2021_sa1, 
                             sa1_irsad_2021 %>% 
                               select("sa1_code_2021", "IRSAD"))


#join SA1 enumerated population
social_2021_sa1 <- full_join(social_2021_sa1, 
                             sa1_age_2021 %>% 
                               select("AGEP Age", "Total"), 
                             by = join_by("sa1_code_2021" == "AGEP Age"))

names(social_2021_sa1) <- c("sa1_code_2021", 
                            "over_60", "age_five_to_nine", 
                            "adult_no_car", 
                            "disability_support_pension",
                            "low_income_families",
                            "adult_not_labour_force",
                            "students", 
                            "IRSAD", 
                            "population")

##Rescaling to 0-100 and adding the accessibility indicator needs to be done on a areas_of_interest by areas_of_interest bias, as which areas are included will matter. 

```

```{r read_ABS_data_2016, fig.show="hold", eval=FALSE, echo = FALSE, warning=FALSE, message=FALSE, cache=TRUE, fig.fullwidth = TRUE, fig.cap="SI scores by SA3, census day 2016 and 2021"}

#read IRSAD 2016 and remove non-data rows
sa1_irsad_2016 <- read_excel("data/2033055001 - sa1 indexes.xls", 
    sheet = "Table 3", skip = 4)
names(sa1_irsad_2016) <- c("sa1_code_2016", 
                           "sa1_code_2016_11_digit", 
                           "usual_resident_population", 
                           "IRSAD",
                           "x4",
                           "rank_in_australia",
                           "decile_in_australia",
                           "percentile_in_australia",
                           "x8",
                           "state", 
                           "rank_in_state", 
                           "decile_in_state", 
                           "percentile_in_state")

sa1_irsad_2016 <- sa1_irsad_2016[-1,]
sa1_irsad_2016 <- sa1_irsad_2016 %>% filter(row_number() <= n()-2)

#read students 2016 and remove non-data rows
sa1_students_2016 <- read_csv("data/sa1_students_ur_2016.csv", 
    skip = 8)
sa1_students_2016 <- sa1_students_2016[-1,]
sa1_students_2016 <- sa1_students_2016 %>% filter(row_number() <= n()-5)

#read not in labour force in 2016 and remove non-data rows
#this dataset contains a single 'wafer', 
# being those people not in the labour force, separated by age and sa1
sa1_not_in_labour_force_2016 <- read_csv("data/sa1_not_in_labour_force_2016.csv", 
    skip = 10)
sa1_not_in_labour_force_2016 <- sa1_not_in_labour_force_2016[-1,]
#not_in_labour_force csv from ABS repeats the entire dataset, hence only read in first set
sa1_not_in_labour_force_2016 <- sa1_not_in_labour_force_2016 %>% filter(row_number() <= n()-5)


#calculate number of adults not in labour force (ie 18+)
sa1_not_in_labour_force_2016$adult_not_labour_force <- rowSums (sa1_not_in_labour_force_2016[,20:117])
  



#read no car in 2016 and remove non-data rows
#this dataset contains a single 'wafer', 
# being those people living in a household with no car, separated by age and sa1
sa1_no_car_2016 <- read_csv("data/sa1_no_vehices_2016.csv", 
    skip = 8)
sa1_no_car_2016 <- sa1_no_car_2016[-1,]
sa1_no_car_2016 <- sa1_no_car_2016 %>% filter(row_number() <= n()-5)
#calculate number of adults with no car (ie 18+)
sa1_no_car_2016$adult_no_car <- rowSums(sa1_no_car_2016[,20:117])


#read low income in 2016 and remove non-data rows
sa1_low_income_2016 <- read_csv("data/sa1_family_income_2016.csv", 
    skip = 8)
sa1_low_income_2016 <- sa1_low_income_2016[-1,]
sa1_low_income_2016 <- sa1_low_income_2016 %>% filter(row_number() <= n()-5)

#read disability support pension DISABILITY SUPPORT PENSION DATA NOT REPORTED IN 2016



#read age in 2016 and remove non-data rows
sa1_age_2016 <- read_csv("data/sa1_ur_agep_2016.csv", 
    skip = 8)
sa1_age_2016 <- sa1_age_2016[-1,]
sa1_age_2016 <- sa1_age_2016 %>% filter(row_number() <= n()-5)

#calculate number of people over 60.
sa1_age_2016$over_60 <- rowSums(sa1_age_2016[,63:117])

#calculate number of persons 5 to 9 years old.
sa1_age_2016$age_five_to_nine <- rowSums(sa1_age_2016[,7:11]) 


## create social indiators table
social_2016_sa1 <- sa1_irsad_2016 %>% 
  select(sa1_code_2016, 
         sa1_code_2016_11_digit,
         usual_resident_population,
         IRSAD)

social_2016_sa1$sa1_code_2016 <- social_2016_sa1$sa1_code_2016 %>% as.character()
social_2016_sa1$sa1_code_2016_11_digit <- social_2016_sa1$sa1_code_2016_11_digit %>% as.character()

#move age-related indicators into social indicators table. 
social_2016_sa1 <- left_join(
  social_2016_sa1,
  sa1_age_2016 %>% 
  select(`AGEP Age`, over_60, age_five_to_nine),
by = join_by( "sa1_code_2016" == "AGEP Age")
)


#join Adults without Cars
social_2016_sa1 <- full_join(social_2016_sa1, 
                             sa1_no_car_2016 %>% 
                               select("AGEP Age", "adult_no_car"), 
                             by = join_by( "sa1_code_2016" == "AGEP Age"))

#join disability pension NOT PRESENT IN THE DATA


#join low income households
sa1_low_income_2016$low_income_families <- rowSums(sa1_low_income_2016[,2:9])
social_2016_sa1 <- full_join(social_2016_sa1, 
                             sa1_low_income_2016 %>% 
                               select("FINASF Total Family Income as Stated (weekly)", "low_income_families"), 
                             by = join_by( "sa1_code_2016" == "FINASF Total Family Income as Stated (weekly)"))


#join adults not in labour force
social_2016_sa1 <- full_join(social_2016_sa1 %>% na.omit(), 
                             sa1_not_in_labour_force_2016 %>% 
                               select("AGEP Age", "adult_not_labour_force") %>%
                               na.omit(), 
                             by = join_by("sa1_code_2016" == "AGEP Age"))

#join students
sa1_students_2016$students <- sa1_students_2016$Total - sa1_students_2016$`Not attending`
social_2016_sa1 <- full_join(social_2016_sa1, 
                             sa1_students_2016 %>% 
                               select("STUP Full-Time/Part-Time Student Status", "students"), 
                             by = join_by( "sa1_code_2016" == "STUP Full-Time/Part-Time Student Status"))


#join SA1 enumerated population
social_2016_sa1 <- full_join(social_2016_sa1, 
                             sa1_age_2016 %>% 
                               select("AGEP Age", "Total"), 
                             by = join_by("sa1_code_2016" == "AGEP Age"))

social_2016_sa1 <- social_2016_sa1 %>% select(
  sa1_code_2016, 
  over_60, 
  age_five_to_nine,
  adult_no_car,
  low_income_families,
  adult_not_labour_force,
  students,
  IRSAD,
  usual_resident_population,
  sa1_code_2016_11_digit
)

names(social_2016_sa1) <- c("sa1_code_2016", 
                            "over_60", "age_five_to_nine", 
                            "adult_no_car", 
                            "low_income_families",
                            "adult_not_labour_force",
                            "students", 
                            "IRSAD", 
                            "population",
                            "sa1_code_2016_11_digit")

social_2016_sa1$IRSAD <- social_2016_sa1$IRSAD %>% as.numeric()

##Rescaling to 0-100 and adding the accessibility indicator needs to be done on a areas_of_interest by areas_of_interest bias, as which areas are included will matter. 

```

# Results


```{r Wexford_2025, fig.show="hold", out.width="100%", echo = FALSE, warning=FALSE, message=FALSE, cache=FALSE, results='hide'}

## FUNCTION to define thresholds and return Very High, High etc. 
# as per Currie2010 Table 3 and page 34. 
# the approach appears to be to first identify zones that have zero supply 
# the remainder are then split into those above and below the average SI value
# these two groups are then each split into three groups of roughly equal size. 
set_thresholds <-function(si_by_area_dataframe){ 

## Define Very High, High etc thresholds
cuts_lower_groups <- si_by_area_dataframe %>% 
  st_drop_geometry() %>% 
  filter(SI !=0) %>%
  filter(SI <= SI %>% mean()) %>% 
  select(SI) %>% unlist() %>% 
  as.vector() %>% 
  quantileCut(3)

cuts_upper_groups <- si_by_area_dataframe %>% 
  st_drop_geometry() %>% 
  filter(SI !=0) %>%
  filter(SI > SI %>% mean()) %>%
  select(SI) %>% unlist() %>% 
  as.vector() %>% 
  quantileCut(3)

# Recode lower_group factors
allocation_lower_groups <- cuts_lower_groups %>% fct_recode(
  "Very Low" = levels(cuts_lower_groups)[1], 
  "Low" = levels(cuts_lower_groups)[2], 
  "Below average" = levels(cuts_lower_groups)[3])

# Recode upper_group factors
allocation_upper_groups <- cuts_upper_groups %>% fct_recode(
  "Above average" = levels(cuts_upper_groups)[1], 
  "High" = levels(cuts_upper_groups)[2], 
  "Very High" = levels(cuts_upper_groups)[3])


# Join back to lower_group SIs and areas_of_interest
si_by_area_dataframe_below_average <- si_by_area_dataframe %>% 
  st_drop_geometry() %>% 
  filter(SI !=0) %>%
  filter(SI <= SI %>% mean()) 
si_by_area_dataframe_below_average$transit_supply <- allocation_lower_groups

# Join back to upper_group SIs and areas_of_interest
si_by_area_dataframe_above_average <- si_by_area_dataframe %>% 
  st_drop_geometry() %>% 
  filter(SI !=0) %>%
  filter(SI > SI %>% mean()) 
si_by_area_dataframe_above_average$transit_supply <- allocation_upper_groups

# combine upper and lower groups
  
si_by_area_dataframe_non_zero <- add_row(si_by_area_dataframe_below_average, 
                                         si_by_area_dataframe_above_average)

#join back to dataframe, and put "Zero" in N/A
si_by_area_dataframe <- full_join(
  si_by_area_dataframe %>% 
    st_drop_geometry(), 
  si_by_area_dataframe_non_zero
)

si_by_area_dataframe$transit_supply <- si_by_area_dataframe$transit_supply %>% 
  fct_explicit_na(na_level = "Zero Supply") %>% 
  fct_shift(n = -1)

#return dataframe and information about level cut offs
si_by_area_dataframe_and_cuts_dataframe <- list(
  si_by_area_dataframe,
  c(levels(cuts_lower_groups), levels(cuts_upper_groups))
  )
return(si_by_area_dataframe_and_cuts_dataframe)
}
# END FUNCTION

## FUNCTION to set thresholds and return tibble, plot output and thresholds
si_thresholds_and_plot_function <- function(si_by_area, areas_of_interest){
# Set column names
names(si_by_area) <- c("area_id", "SI")
names(areas_of_interest) <- c("area_id", "geometry")
  
si_by_area$area_id <- si_by_area$area_id %>% 
  as.character()


##Join to areas_of_interest so as to identify (and enumerate as zero) 
# those areas of interest that have no SI score 

si_by_area <- full_join(
  areas_of_interest,
  si_by_area)
si_by_area[is.na(si_by_area)] <- 0

si_by_area_thresholds <- set_thresholds(si_by_area_dataframe = si_by_area)
si_by_area <- si_by_area_thresholds[[1]]


si_by_area <- left_join(
  areas_of_interest, 
  si_by_area)

output_plot <- ggplot()+ 
  geom_sf(data=si_by_area %>% na.omit(),
          aes(fill = transit_supply), colour=NA) +
  theme(axis.text.x=element_blank(), #remove x axis labels
        axis.ticks.x=element_blank(), #remove x axis ticks
        axis.text.y=element_blank(),  #remove y axis labels
        axis.ticks.y=element_blank(), #remove y axis ticks
        legend.position="none",
#        legend.text = element_text(size = 4), 
#        legend.title = element_text(size = 5), 
#        legend.key.size = unit(0.08, 'cm')
        ) + 
  scale_fill_manual(values = c("white", "#F9D8B1", "#F7C387", "#F29C33", "lightgreen", "#53A212", "darkgreen")) 


  outputs <- list("si_by_area" = si_by_area, 
                  "output_plot" = output_plot, 
                  "thresholds" = si_by_area_thresholds[[2]])
  return(outputs)
}

### Load 2025 results
si_by_area <- read.csv("results/si_wexford_250423_day_aggregated.csv") %>% 
  as_tibble()
si_by_area <- si_by_area[,2:3]


#Load Wexford codes


Small_Area_National_Statistical_Boundaries_2022 <- st_read("data/Small_Area_National_Statistical_Boundaries_2022_Ungeneralised_view_-7354763930310470674.gpkg")
st_geometry(Small_Area_National_Statistical_Boundaries_2022) <- "SHAPE"

wexford <- Small_Area_National_Statistical_Boundaries_2022 %>% 
  filter(COUNTY_ENGLISH == "WEXFORD") %>%
  select(SA_GUID_2022, SA_PUB2022, SA_URBAN_AREA_NAME, SA_NUTS2_NAME, SA_NUTS3_NAME)

names(wexford) <- c("SA_GUID_2022", "SA_PUB2022", "SA_URBAN_AREA_NAME", "SA_NUTS2_NAME", "SA_NUTS3_NAME", "geometry" )
wexford <- wexford %>% st_set_geometry("geometry")

#Load Wexford codes
areas_of_interest <- load_areas_of_interest(wexford,  
  area_id_field = "SA_PUB2022")

si_wexford_250423_day_aggregated <- si_thresholds_and_plot_function(si_by_area, areas_of_interest)

## Connect SI results to area definitions
si_wexford_250423_day_aggregated$si_by_area <- left_join(
  si_wexford_250423_day_aggregated$si_by_area,
  wexford %>% st_drop_geometry(), 
  by=join_by("area_id" == "SA_PUB2022"))


## Import population data
## T1_1AGETT is total population field.  
# GUID is identification field
SAPS_2022_Small_Area_UR_171024 <- read_csv("data/SAPS_2022_Small_Area_UR_171024.csv") %>% select(GUID, T1_1AGETT) 

names(SAPS_2022_Small_Area_UR_171024) <- c("GUID", "population")

si_wexford_250423_day_aggregated$si_by_area <- left_join(
  si_wexford_250423_day_aggregated$si_by_area,
  SAPS_2022_Small_Area_UR_171024, 
  by=join_by("SA_GUID_2022" == "GUID"))

# Categorise population into Very High, High groups etc.
wexford_population <- si_wexford_250423_day_aggregated$si_by_area %>% 
  st_drop_geometry() %>% 
  select(area_id, population)
names(wexford_population) <- c("area_id", "SI")
wexford_population <- set_thresholds(wexford_population)
names(wexford_population[[1]]) <- c("area_id", "population", "population_category")

si_wexford_250423_day_aggregated$si_by_area$population_category <- 
  wexford_population[[1]]$population_category

si_wexford_250423_day_aggregated$si_by_area$population_category <- 
  si_wexford_250423_day_aggregated$si_by_area$population_category %>%
  factor(levels=c("Very Low", "Low", "Below average", "Above average", "High", "Very High"))

#Calculate population density
si_wexford_250423_day_aggregated$si_by_area$population_density <- 
  si_wexford_250423_day_aggregated$si_by_area$population %>% st_drop_geometry() /
  si_wexford_250423_day_aggregated$si_by_area %>% st_area()
#Categorise population density  
wexford_population_density <- si_wexford_250423_day_aggregated$si_by_area %>% 
  st_drop_geometry() %>% 
  select(area_id, population_density)
names(wexford_population_density) <- c("area_id", "SI")
wexford_population_density$SI <- wexford_population_density$SI %>%
  as.numeric()
  
wexford_population_density <- set_thresholds(wexford_population_density)
names(wexford_population_density[[1]]) <- c("area_id", "population_density", "density_category")

si_wexford_250423_day_aggregated$si_by_area$density_category <- 
  wexford_population_density[[1]]$density_category

si_wexford_250423_day_aggregated$si_by_area$density_category <- 
  si_wexford_250423_day_aggregated$si_by_area$density_category %>%
  factor(levels=c("Very Low", "Low", "Below average", "Above average", "High", "Very High"))



```



```{r SI_map_wexford_county_population, fig.show="hold", eval = TRUE, echo = FALSE, warning=FALSE, message=FALSE, cache=FALSE, fig.margin = TRUE, fig.cap="Transit Supply across County Wexford, by population"}


#Set boundings box
bbox_list <- wexford %>% 
  st_geometry %>% 
  st_combine() %>%
  st_bbox()


lat = c(bbox_list["ymin"] %>% as.numeric(), bbox_list["ymax"] %>% as.numeric())
lon = c(bbox_list["xmin"] %>% as.numeric(), bbox_list["xmax"] %>% as.numeric() + 0*(bbox_list["xmax"] %>% as.numeric() - bbox_list["xmin"] %>% as.numeric()))

Poly_Coord_df = data.frame(lon, lat)

poly <- Poly_Coord_df %>% 
  st_as_sf(coords = c("lon", "lat"), 
           crs = 2157) %>% 
  st_bbox() %>% 
  st_as_sfc()


pcol <- si_wexford_250423_day_aggregated$si_by_area %>%
  st_drop_geometry() %>%
  aggregate(population ~ transit_supply, sum) %>%
  right_join(tibble(transit_supply = si_wexford_250423_day_aggregated$si_by_area$transit_supply %>% levels())) %>%
  replace_na(list(population = 0)) %>%
  mutate(transit_supply=factor(transit_supply, levels = si_wexford_250423_day_aggregated$si_by_area$transit_supply %>% levels())) %>%
  arrange(transit_supply) %>%
  mutate(perc=population/sum(population)) %>% 
  na.omit() %>%
  ggplot() + 
  geom_col(aes(transit_supply, perc, fill = transit_supply), colour="black") +
  scale_y_continuous(limits = c(0,.6)) +
  geom_hline(yintercept = 0)  + 
  geom_text(aes(transit_supply,  0.5, label = glue::glue("{label_comma(accuracy = 1, big.mark = ",")(population)} ({label_percent(accuracy = 1)(perc)})")), size = 4) +
   coord_flip() + 
scale_fill_manual(values = c("Zero Supply" = "white", "Very Low" = "#F9D8B1", "Low" = "#F7C387", "Below average" = "#F29C33", "Above average" = "lightgreen", "High" = "#53A212", "Very High" = "darkgreen")) +
  scale_color_manual(values = c(rep("black", 5), rep("white", 2), "black")) +
  guides(fill = "none", color = "none") +
  labs(
    title = "",
    x = NULL,
    y = NULL
  ) +
  theme_void() +
  theme(
    panel.grid = element_blank(),
    plot.title = element_text(size = 8),
    axis.text.y = element_text(size = 15, hjust = 1),
    axis.text.x = element_blank()
  ) 


pcol

```


The distribution of transit supply by population across County Wexford is shown in Figure 1. Figure 2 shows the distribution of transit supply by Small Area. 


```{r SI_map_wexford_county, fig.show="hold", eval = TRUE, echo = FALSE, warning=FALSE, message=FALSE, cache=FALSE, fig.fullwidth = FALSE, ncol = 1, out.width="100%", fig.height = 2.5, fig.cap="Transit Supply across County Wexford, by Small Area"}


ggplot()+ 
  geom_sf(data=si_wexford_250423_day_aggregated$si_by_area,
          aes(fill = transit_supply), colour=NA) +
  theme(axis.text.x=element_blank(), #remove x axis labels
        axis.ticks.x=element_blank(), #remove x axis ticks
        axis.text.y=element_blank(),  #remove y axis labels
        axis.ticks.y=element_blank(), #remove y axis ticks
        legend.position="none",
#        legend.text = element_text(size = 4), 
#        legend.title = element_text(size = 5), 
#        legend.key.size = unit(0.08, 'cm')
        ) + 
scale_fill_manual(values = c("Zero Supply" = "white", "Very Low" = "#F9D8B1", "Low" = "#F7C387", "Below average" = "#F29C33", "Above average" = "lightgreen", "High" = "#53A212", "Very High" = "darkgreen")) +
    coord_sf(xlim = c(lon[1],lon[2]), 
           ylim = c(lat[1], lat[2])) +
  ggspatial::annotation_scale(location = 'bl') +
  ggspatial::annotation_north_arrow(location = 'tl', height = unit(0.5, "cm"), width = unit(0.5, "cm")) 
#+ 
#inset_element(pcol, left = 0.4, bottom = 0.0, right = 1.0, top =0.5) 
 

```


`r pcol$data[1,3] %>% label_percent(accuracy = 1)()` of County Wexford residents live in Small Areas that have no transit service at all, while `r pcol$data[2:4,3] %>% sum() %>% label_percent(accuracy = 1)()` live in areas with 
lower than the average supply level. 
In general, 
and as might be expected, 
transit supply appears to be focused 
most in the urban areas of Wexford (town), Enniscorthy, Gorey and New Ross, 

```{r SI_map_wexford_enniscorthy, fig.show="hold", eval = TRUE, echo = FALSE, warning=FALSE, message=FALSE, cache=FALSE, fig.fullwidth = TRUE, ncol = 2, out.width="50%", fig.height = 2.5, fig.cap="Transit Supply across Enniscorthy (left) and Wexford (right), by Small Area (maps) and population (charts)"}


si_wexford_250423_day_aggregated$si_by_area$transit_supply_combined <- si_wexford_250423_day_aggregated$si_by_area$transit_supply %>% fct_collapse("Very Low or Low" = c("Very Low", "Low"))


enniscorthy_wexford_comparison <- si_wexford_250423_day_aggregated$si_by_area %>%
  st_drop_geometry() %>% 
  filter(SA_URBAN_AREA_NAME == "Wexford" | SA_URBAN_AREA_NAME == "Enniscorthy") %>%
  mutate(transit_supply_combined = fct_drop(transit_supply_combined)) %>% 
  tabyl(transit_supply_combined, SA_URBAN_AREA_NAME) %>% 
  chisq.test()

#enniscorthy_wexford_comparison$expected
# assumption met. 2 of 12 < 5


#Set boundings box
bbox_list <- wexford %>% 
  filter(SA_URBAN_AREA_NAME == "Enniscorthy") %>%
  st_geometry %>% 
  st_combine() %>%
  st_bbox()


lat = c(bbox_list["ymin"] %>% as.numeric(), bbox_list["ymax"] %>% as.numeric())
lon = c(bbox_list["xmin"] %>% as.numeric(), bbox_list["xmax"] %>% as.numeric() + 0*(bbox_list["xmax"] %>% as.numeric() - bbox_list["xmin"] %>% as.numeric()))

Poly_Coord_df = data.frame(lon, lat)

poly <- Poly_Coord_df %>% 
  st_as_sf(coords = c("lon", "lat"), 
           crs = 2157) %>% 
  st_bbox() %>% 
  st_as_sfc()


pcol_enniscorthy <- si_wexford_250423_day_aggregated$si_by_area %>% 
  st_drop_geometry() %>%
  filter(SA_URBAN_AREA_NAME == "Enniscorthy") %>%
  aggregate(population ~ transit_supply_combined, sum) %>%
  right_join(tibble(transit_supply_combined = si_wexford_250423_day_aggregated$si_by_area$transit_supply_combined %>% levels())) %>%
  replace_na(list(population = 0)) %>%
  mutate(transit_supply_combined=factor(transit_supply_combined, levels = si_wexford_250423_day_aggregated$si_by_area$transit_supply_combined %>% levels())) %>%
  arrange(transit_supply_combined) %>%
  mutate(perc=population/sum(population)) %>% 
  na.omit() %>%
  ggplot() + 
  geom_col(aes(transit_supply_combined, perc, fill = transit_supply_combined), colour="black") +
  scale_y_continuous(limits = c(0,.7)) +
  geom_hline(yintercept = 0)  + 
  geom_text(aes(transit_supply_combined,  0.5, label = glue::glue("{label_comma(accuracy = 1, big.mark = ",")(population)} ({label_percent(accuracy = 1)(perc)})")), size = 1.5) +
   coord_flip() + 
scale_fill_manual(values = c("Zero Supply" = "white", "Very Low or Low" = "#F8CD9C", "Below average" = "#F29C33", "Above average" = "lightgreen", "High" = "#53A212", "Very High" = "darkgreen")) +
  scale_color_manual(values = c(rep("black", 5), rep("white", 2), "black")) +
  guides(fill = "none", color = "none") +
  labs(
    title = "Enniscorthy (by pop.)",
    x = NULL,
    y = NULL
  ) +
  theme_void() +
  theme(
    panel.grid = element_blank(),
    plot.title = element_text(size = 6),
    axis.text.y = element_text(size = 5, hjust = 1),
    axis.text.x = element_blank()
  ) 



ggplot()+ 
  geom_sf(data=si_wexford_250423_day_aggregated$si_by_area %>%
          filter(SA_URBAN_AREA_NAME == "Enniscorthy"),
          aes(fill = transit_supply_combined), colour=NA) +
  theme(axis.text.x=element_blank(), #remove x axis labels
        axis.ticks.x=element_blank(), #remove x axis ticks
        axis.text.y=element_blank(),  #remove y axis labels
        axis.ticks.y=element_blank(), #remove y axis ticks
        legend.position="none",
#        legend.text = element_text(size = 4), 
#        legend.title = element_text(size = 5), 
#        legend.key.size = unit(0.08, 'cm')
        ) + 
scale_fill_manual(values = c("Zero Supply" = "white", "Very Low or Low" = "#F8CD9C", "Below average" = "#F29C33", "Above average" = "lightgreen", "High" = "#53A212", "Very High" = "darkgreen")) +
    coord_sf(xlim = c(lon[1],lon[2]), 
           ylim = c(lat[1], lat[2])) +
  #ggspatial::annotation_scale(location = 'tr') +
  ggspatial::annotation_north_arrow(location = 'tl', height = unit(0.5, "cm"), width = unit(0.5, "cm"))   +
  inset_element(pcol_enniscorthy, left = 0.25, bottom = 0.0, right = 1.00, top =0.3) 

 

#Set boundings box
wexford_bbox_list <- wexford %>% 
  filter(SA_URBAN_AREA_NAME == "Wexford") %>%
  st_geometry %>% 
  st_combine() %>%
  st_bbox()


lat = c(wexford_bbox_list["ymin"] %>% as.numeric(), 
        bbox_list["ymax"] %>% as.numeric()-bbox_list["ymin"] %>% as.numeric() + wexford_bbox_list["ymin"] %>% as.numeric())
lon = c(wexford_bbox_list["xmin"] %>% as.numeric(), 
         1 * (bbox_list["xmax"] %>% as.numeric() -  bbox_list["xmin"] %>% as.numeric()) + wexford_bbox_list["xmin"] %>% as.numeric())
        
Poly_Coord_df = data.frame(lon, lat)

poly <- Poly_Coord_df %>% 
  st_as_sf(coords = c("lon", "lat"), 
           crs = 2157) %>% 
  st_bbox() %>% 
  st_as_sfc()


pcol_1 <- si_wexford_250423_day_aggregated$si_by_area %>% 
  st_drop_geometry() %>%
  filter(SA_URBAN_AREA_NAME == "Wexford") %>%
  aggregate(population ~ transit_supply_combined, sum) %>%
  right_join(tibble(transit_supply_combined = si_wexford_250423_day_aggregated$si_by_area$transit_supply_combined %>% levels())) %>%
  replace_na(list(population = 0)) %>%
  mutate(transit_supply_combined=factor(transit_supply_combined, levels = si_wexford_250423_day_aggregated$si_by_area$transit_supply_combined %>% levels())) %>%
  arrange(transit_supply_combined) %>%
  mutate(perc=population/sum(population)) %>% 
  na.omit() %>%
  ggplot() + 
  geom_col(aes(transit_supply_combined, perc, fill = transit_supply_combined), colour="black") +
  scale_y_continuous(limits = c(0,.7)) +
  geom_hline(yintercept = 0)  + 
  geom_text(aes(transit_supply_combined,  0.5, label = glue::glue("{label_comma(accuracy = 1, big.mark = ",")(population)} ({label_percent(accuracy = 1)(perc)})")), size = 1.5) +
   coord_flip() + 
scale_fill_manual(values = c("Zero Supply" = "white", "Very Low or Low" = "#F8CD9C", "Below average" = "#F29C33", "Above average" = "lightgreen", "High" = "#53A212", "Very High" = "darkgreen")) +
  scale_color_manual(values = c(rep("black", 5), rep("white", 2), "black")) +
  guides(fill = "none", color = "none") +
  labs(
    title = "Wexford (town, by pop.)",
    x = NULL,
    y = NULL
  ) +
  theme_void() +
  theme(
    panel.grid = element_blank(),
    plot.title = element_text(size = 6),
    axis.text.y = element_text(size = 5, hjust = 1),
    axis.text.x = element_blank()
  ) 



ggplot()+ 
  geom_sf(data=si_wexford_250423_day_aggregated$si_by_area %>%
          filter(SA_URBAN_AREA_NAME == "Wexford"),
          aes(fill = transit_supply_combined), colour=NA) +
  theme(axis.text.x=element_blank(), #remove x axis labels
        axis.ticks.x=element_blank(), #remove x axis ticks
        axis.text.y=element_blank(),  #remove y axis labels
        axis.ticks.y=element_blank(), #remove y axis ticks
        legend.position="none",
#        legend.text = element_text(size = 4), 
#        legend.title = element_text(size = 5), 
#        legend.key.size = unit(0.08, 'cm')
        ) + 
scale_fill_manual(values = c("Zero Supply" = "white", "Very Low or Low" = "#F8CD9C", "Below average" = "#F29C33", "Above average" = "lightgreen", "High" = "#53A212", "Very High" = "darkgreen")) +
    coord_sf(xlim = c(lon[1],lon[2]), 
           ylim = c(lat[1], lat[2])) +
  ggspatial::annotation_scale(location = 'tr') +
#  ggspatial::annotation_north_arrow(location = 'tl', height = unit(0.75, "cm")) + 
  inset_element(pcol_1, left = 0.25, bottom = 0.0, right = 1.00, top =0.3) 



```



Figure 3 compares transit supply in Enniscorthy and Wexford (town).  
In Enniscorthy `r pcol_enniscorthy$data[1:3,3] %>% sum() %>% label_percent(accuracy = 1)()` 
of residents live in Small Areas with less than the (County-Wexford-wide) average transit supply. This compares to only `r pcol_1$data[1:3,3] %>% sum() %>% label_percent(accuracy = 1)()` in Wexford (town)^[Differences between Enniscorthy and Wexford (town) are statistically significant^(`r prmisc::print_chi2(enniscorthy_wexford_comparison)`]. 


```{r SI_map_gorey_new_ross, fig.show="hold", eval = TRUE, echo = FALSE, warning=FALSE, message=FALSE, cache=FALSE, fig.fullwidth = TRUE, ncol = 2, out.width="50%", fig.height = 2.5, fig.cap="Transit Supply across Gorey (left) and New Ross (right), by Small Area (maps) and population (charts)"}



enniscorthy_gorey_comparison <- si_wexford_250423_day_aggregated$si_by_area %>%
  st_drop_geometry() %>% 
  filter(SA_URBAN_AREA_NAME == "Gorey" | SA_URBAN_AREA_NAME == "Enniscorthy") %>%
  mutate(transit_supply_combined = fct_drop(transit_supply_combined)) %>% 
  tabyl(transit_supply_combined, SA_URBAN_AREA_NAME) %>% 
  chisq.test()

# enniscorthy_gorey_comparison$expected
# assumption met. 2 of 12 < 5


#Set boundings box

#Set boundings box
gorey_bbox_list <- wexford %>% 
  filter(SA_URBAN_AREA_NAME == "Gorey") %>%
  st_geometry %>% 
  st_combine() %>%
  st_bbox()


lat = c(gorey_bbox_list["ymax"] %>% as.numeric() - 
          (bbox_list["ymax"] %>% as.numeric() -
             bbox_list["ymin"] %>% as.numeric()), 
         gorey_bbox_list["ymax"] %>% as.numeric())
lon = c(gorey_bbox_list["xmin"] %>% as.numeric(), 
         1 * (bbox_list["xmax"] %>% as.numeric() -  bbox_list["xmin"] %>% as.numeric()) + gorey_bbox_list["xmin"] %>% as.numeric())
        
Poly_Coord_df = data.frame(lon, lat)

poly <- Poly_Coord_df %>% 
  st_as_sf(coords = c("lon", "lat"), 
           crs = 2157) %>% 
  st_bbox() %>% 
  st_as_sfc()


pcol <- si_wexford_250423_day_aggregated$si_by_area %>% 
  st_drop_geometry() %>%
  filter(SA_URBAN_AREA_NAME == "Gorey") %>%
  aggregate(population ~ transit_supply_combined, sum) %>%
  right_join(tibble(transit_supply_combined = si_wexford_250423_day_aggregated$si_by_area$transit_supply_combined %>% levels())) %>%
  replace_na(list(population = 0)) %>%
  mutate(transit_supply_combined=factor(transit_supply_combined, levels = si_wexford_250423_day_aggregated$si_by_area$transit_supply_combined %>% levels())) %>%
  arrange(transit_supply_combined) %>%
  mutate(perc=population/sum(population)) %>% 
  na.omit() %>%
  ggplot() + 
  geom_col(aes(transit_supply_combined, perc, fill = transit_supply_combined), colour="black") +
  scale_y_continuous(limits = c(0,.7)) +
  geom_hline(yintercept = 0)  + 
  geom_text(aes(transit_supply_combined,  0.5, label = glue::glue("{label_comma(accuracy = 1, big.mark = ",")(population)} ({label_percent(accuracy = 1)(perc)})")), size = 1.5) +
   coord_flip() + 
scale_fill_manual(values = c("Zero Supply" = "white", "Very Low or Low" = "#F8CD9C", "Below average" = "#F29C33", "Above average" = "lightgreen", "High" = "#53A212", "Very High" = "darkgreen")) +
  scale_color_manual(values = c(rep("black", 5), rep("white", 2), "black")) +
  guides(fill = "none", color = "none") +
  labs(
    title = "Gorey (by pop.)",
    x = NULL,
    y = NULL
  ) +
  theme_void() +
  theme(
    panel.grid = element_blank(),
    plot.title = element_text(size = 5),
    axis.text.y = element_text(size = 4, hjust = 1),
    axis.text.x = element_blank()
  ) 



ggplot()+ 
  geom_sf(data=si_wexford_250423_day_aggregated$si_by_area %>%
          filter(SA_URBAN_AREA_NAME == "Gorey"),
          aes(fill = transit_supply_combined), colour=NA) +
  theme(axis.text.x=element_blank(), #remove x axis labels
        axis.ticks.x=element_blank(), #remove x axis ticks
        axis.text.y=element_blank(),  #remove y axis labels
        axis.ticks.y=element_blank(), #remove y axis ticks
        legend.position="none",
#        legend.text = element_text(size = 4), 
#        legend.title = element_text(size = 5), 
#        legend.key.size = unit(0.08, 'cm')
        ) + 
scale_fill_manual(values = c("Zero Supply" = "white", "Very Low or Low" = "#F8CD9C", "Below average" = "#F29C33", "Above average" = "lightgreen", "High" = "#53A212", "Very High" = "darkgreen")) +
    coord_sf(xlim = c(lon[1],lon[2]), 
           ylim = c(lat[1], lat[2])) +
  #ggspatial::annotation_scale(location = 'tr') +
   ggspatial::annotation_north_arrow(location = 'tl', height = unit(0.5, "cm"), width = unit(0.5, "cm")) +
  inset_element(pcol, left = 0.25, bottom = 0.0, right = 1.00, top =0.3) 

 

si_wexford_250423_day_aggregated$si_by_area$transit_supply_combined <- si_wexford_250423_day_aggregated$si_by_area$transit_supply %>% fct_collapse("Zero or Low Supply" = c("Zero Supply", "Low"))


si_wexford_250423_day_aggregated$si_by_area$transit_supply_combined <- si_wexford_250423_day_aggregated$si_by_area$transit_supply_combined %>% fct_collapse("High or Very High" = c("High", "Very High"))




enniscorthy_new_ross_comparison <- si_wexford_250423_day_aggregated$si_by_area %>%
  st_drop_geometry() %>% 
  filter(SA_URBAN_AREA_NAME == "New Ross" | SA_URBAN_AREA_NAME == "Enniscorthy") %>%
  mutate(transit_supply_combined = fct_drop(transit_supply_combined)) %>% 
  tabyl(transit_supply_combined, SA_URBAN_AREA_NAME) %>% 
  chisq.test()

# enniscorthy_new_ross_comparison$expected
# assumption met. all over 5




#Set boundings box
new_ross_bbox_list <- wexford %>% 
  filter(SA_URBAN_AREA_NAME == "New Ross") %>%
  st_geometry %>% 
  st_combine() %>%
  st_bbox()

lat = c(new_ross_bbox_list["ymax"] %>% as.numeric() - 
          (bbox_list["ymax"] %>% as.numeric() -
             bbox_list["ymin"] %>% as.numeric()), 
         new_ross_bbox_list["ymax"] %>% as.numeric())
lon = c(new_ross_bbox_list["xmin"] %>% as.numeric(), 
         1 * (bbox_list["xmax"] %>% as.numeric() -  bbox_list["xmin"] %>% as.numeric()) + new_ross_bbox_list["xmin"] %>% as.numeric())


Poly_Coord_df = data.frame(lon, lat)

poly <- Poly_Coord_df %>% 
  st_as_sf(coords = c("lon", "lat"), 
           crs = 2157) %>% 
  st_bbox() %>% 
  st_as_sfc()


pcol_1 <- si_wexford_250423_day_aggregated$si_by_area %>% 
  st_drop_geometry() %>%
  filter(SA_URBAN_AREA_NAME == "New Ross") %>%
  aggregate(population ~ transit_supply_combined, sum) %>%
  right_join(tibble(transit_supply_combined = si_wexford_250423_day_aggregated$si_by_area$transit_supply_combined %>% levels())) %>%
  replace_na(list(population = 0)) %>%
  mutate(transit_supply_combined=factor(transit_supply_combined, levels = si_wexford_250423_day_aggregated$si_by_area$transit_supply_combined %>% levels())) %>%
  arrange(transit_supply_combined) %>%
  mutate(perc=population/sum(population)) %>% 
  na.omit() %>%
  ggplot() + 
  geom_col(aes(transit_supply_combined, perc, fill = transit_supply_combined), colour="black") +
  scale_y_continuous(limits = c(0,.7)) +
  geom_hline(yintercept = 0)  + 
  geom_text(aes(transit_supply_combined,  0.5, label = glue::glue("{label_comma(accuracy = 1, big.mark = ",")(population)} ({label_percent(accuracy = 1)(perc)})")), size = 1.5) +
   coord_flip() + 
scale_fill_manual(values = c("Zero or Low Supply" = "#F8CD9C", "Below average" = "#F29C33", "Above average" = "lightgreen", "High or Very High" = "#2F8109")) +
  scale_color_manual(values = c(rep("black", 5), rep("white", 2), "black")) +
  guides(fill = "none", color = "none") +
  labs(
    title = "New Ross (by pop.)",
    x = NULL,
    y = NULL
  ) +
  theme_void() +
  theme(
    panel.grid = element_blank(),
    plot.title = element_text(size = 5),
    axis.text.y = element_text(size = 4, hjust = 1),
    axis.text.x = element_blank()
  ) 



ggplot()+ 
  geom_sf(data=si_wexford_250423_day_aggregated$si_by_area %>%
          filter(SA_URBAN_AREA_NAME == "New Ross"),
          aes(fill = transit_supply_combined), colour=NA) +
  theme(axis.text.x=element_blank(), #remove x axis labels
        axis.ticks.x=element_blank(), #remove x axis ticks
        axis.text.y=element_blank(),  #remove y axis labels
        axis.ticks.y=element_blank(), #remove y axis ticks
        legend.position="none",
#        legend.text = element_text(size = 4), 
#        legend.title = element_text(size = 5), 
#        legend.key.size = unit(0.08, 'cm')
        ) + 
scale_fill_manual(values = c("Zero or Low Supply" = "#F8CD9C", "Below average" = "#F29C33", "Above average" = "lightgreen", "High or Very High" = "#2F8109")) +
    coord_sf(xlim = c(lon[1],lon[2]), 
           ylim = c(lat[1], lat[2])) +
  ggspatial::annotation_scale(location = 'tr') +
#  ggspatial::annotation_north_arrow(location = 'tl', height = unit(0.75, "cm")) + 
  inset_element(pcol_1, left = 0.25, bottom = 0.0, right = 1.00, top =0.3) 



```


Figure 4 shows transit supply in Gorey and New Ross. Differences between Enniscorthy and Goery were statistically significant^[(`r prmisc::print_chi2(enniscorthy_gorey_comparison)`]. 
In Goery `r pcol$data[1:3,3] %>% sum() %>% label_percent(accuracy = 1)()` 
of residents live in Small Areas with less than the (County-Wexford-wide) average transit supply, which is a greater proportion than in Enniscorthy (`r pcol_enniscorthy$data[1:3,3] %>% sum() %>% label_percent(accuracy = 1)()`) 
Differences between Enniscorthy and New Ross were not statistically significant^[(`r prmisc::print_chi2(enniscorthy_new_ross_comparison)`], with 
`r pcol_1$data[1:3,3] %>% sum() %>% label_percent(accuracy = 1)()` 
of New Ross residents living in Small Areas with less than the (County-Wexford-wide) average transit supply. 




